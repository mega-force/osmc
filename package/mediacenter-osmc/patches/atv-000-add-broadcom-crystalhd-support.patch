From 9c5ba5b0e9738b863f8723560795ff332ee682f8 Mon Sep 17 00:00:00 2001
From: Sam Nazarko <email@samnazarko.co.uk>
Date: Sun, 11 Oct 2015 14:46:03 +0100
Subject: [PATCH] Add support for CrystalHD. Do not use fast_memcpy() and
 remove CHD pathways which don't make sense (MPEG2, VC1)

Signed-off-by: Sam Nazarko <email@samnazarko.co.uk>
---
 .gitignore                                         |    1 +
 configure.ac                                       |   52 +
 docs/README.linux                                  |   33 +-
 lib/win32/libcrystalhd/bc_dts_defs.h               |  635 +++++++
 lib/win32/libcrystalhd/bc_dts_types.h              |   68 +
 lib/win32/libcrystalhd/libcrystalhd_if.h           | 1539 +++++++++++++++
 lib/win32/libcrystalhd/libcrystalhd_version.h      |   82 +
 project/VS2010Express/XBMC.vcxproj                 |   15 +-
 project/VS2010Express/XBMC.vcxproj.filters         |   12 +
 system/settings/settings.xml                       |    9 +
 tools/depends/target/Makefile                      |    6 +-
 tools/depends/target/libcrystalhd/Makefile         |   15 +
 .../target/libcrystalhd/libcrystalhd/bc_dts_defs.h |  635 +++++++
 .../libcrystalhd/libcrystalhd/bc_dts_types.h       |   68 +
 .../libcrystalhd/libcrystalhd/libcrystalhd_if.h    | 1515 +++++++++++++++
 .../libcrystalhd/libcrystalhd_version.h            |   80 +
 xbmc/Application.cpp                               |   11 +
 xbmc/DllPaths_generated.h.in                       |   11 +
 xbmc/DllPaths_win32.h                              |    1 +
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |   25 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp | 2010 ++++++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h   |  236 +++
 .../DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp     |  204 ++
 .../DVDCodecs/Video/DVDVideoCodecCrystalHD.h       |   51 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |    4 +
 xbmc/settings/SettingConditions.cpp                |    8 +
 xbmc/system.h                                      |    1 +
 xbmc/win32/WIN32Util.cpp                           |   41 +
 xbmc/win32/WIN32Util.h                             |    2 +
 29 files changed, 7345 insertions(+), 25 deletions(-)
 create mode 100644 lib/win32/libcrystalhd/bc_dts_defs.h
 create mode 100644 lib/win32/libcrystalhd/bc_dts_types.h
 create mode 100644 lib/win32/libcrystalhd/libcrystalhd_if.h
 create mode 100644 lib/win32/libcrystalhd/libcrystalhd_version.h
 create mode 100644 tools/depends/target/libcrystalhd/Makefile
 create mode 100644 tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_defs.h
 create mode 100644 tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_types.h
 create mode 100644 tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_if.h
 create mode 100644 tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_version.h
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h

diff --git a/.gitignore b/.gitignore
index 5cf42e7..f551c0e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -508,6 +508,7 @@ lib/cpluff/stamp-h1
 /xbmc/cores/dvdplayer/DVDCodecs/Makefile
 /xbmc/cores/dvdplayer/DVDCodecs/Overlay/Makefile
 /xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/Makefile
+/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD/Makefile
 /xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile
 /xbmc/cores/dvdplayer/DVDDemuxers/Makefile
 /xbmc/cores/dvdplayer/DVDSubtitles/Makefile
diff --git a/configure.ac b/configure.ac
index d2cd5b2..4113fab 100644
--- a/configure.ac
+++ b/configure.ac
@@ -200,6 +200,8 @@ vdpau_not_found="== Could not find libvdpau. VDPAU support disabled. =="
 vdpau_disabled="== VDPAU support manually disabled. =="
 vaapi_not_found="== Could not find libva. VAAPI support disabled. =="
 vaapi_disabled="== VAAPI support manually disabled. =="
+crystalhd_not_found="== Could not find libcrystalhd. CrystalHD support disabled. =="
+crystalhd_disabled="== CrystalHD support manually disabled. =="
 vtbdecoder_enabled="== VTBDecoder support enabled. =="
 vtbdecoder_disabled="== VTBDecoder support manually disabled. =="
 openmax_disabled="== OpenMax support manually disabled. =="
@@ -286,6 +288,12 @@ AC_ARG_ENABLE([vaapi],
   [use_vaapi=$enableval],
   [use_vaapi=auto])
 
+AC_ARG_ENABLE([crystalhd],
+  [AS_HELP_STRING([--enable-crystalhd],
+  [enable CrystalHD decoding (default is auto)])],
+  [use_crystalhd=$enableval],
+  [use_crystalhd=auto])
+
 AC_ARG_ENABLE([vtbdecoder],
   [AS_HELP_STRING([--enable-vtbdecoder],
   [enable VTBDecoder decoding (default is auto)])],
@@ -645,6 +653,7 @@ case $host in
      use_joystick=no
      use_neon=yes
      use_libcec=no
+     use_crystalhd=no
      use_vtbdecoder=yes
      use_optical_drive=no
      use_dvdcss=no
@@ -670,6 +679,7 @@ case $host in
   powerpc-apple-darwin*)
      use_joystick=no
      use_vtbdecoder=no
+     use_crystalhd=no
      ARCH="powerpc-osx"
      use_arch="ppc"
      DEPENDS_ROOT_FOR_XCODE=$(echo ${prefix%/*})
@@ -1887,6 +1897,41 @@ else
   USE_VAAPI=0
 fi
 
+# CrystalHD
+if test "x$use_crystalhd" != "xno"; then
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="-D__LINUX_USER__"
+  AC_CHECK_HEADER([libcrystalhd/libcrystalhd_if.h], [],
+    [ if test "x$use_crystalhd" = "xyes"; then
+        AC_MSG_ERROR($crystalhd_not_found)
+      else
+        use_crystalhd=no
+        AC_MSG_RESULT($crystalhd_not_found)
+      fi
+      USE_CRYSTALHD=0
+    ])
+    CFLAGS="$SAVE_CFLAGS"
+    if test "$host_vendor" != "apple"; then
+      XB_FIND_SONAME([CRYSTALHD], [crystalhd], [use_crystalhd])
+    fi
+    if test "x$use_crystalhd" != "xno"; then
+      SAVE_CFLAGS="$CFLAGS"
+      CFLAGS="-D__LINUX_USER__ -lcrystalhd"
+      # check for new crystalhd lib
+      AC_COMPILE_IFELSE(
+        [AC_LANG_SOURCE([#include <libcrystalhd/bc_dts_types.h>
+          #include <libcrystalhd/bc_dts_defs.h>
+          PBC_INFO_CRYSTAL bCrystalInfo;])],
+        [ AC_DEFINE([HAVE_LIBCRYSTALHD], [2], [Define to 2 if you have the 'New Broadcom Crystal HD' library.]) ], 
+        [ AC_DEFINE([HAVE_LIBCRYSTALHD], [1], [Define to 1 if you have the 'Old Broadcom Crystal HD' library.]) ])
+      CFLAGS="$SAVE_CFLAGS"
+      USE_CRYSTALHD=1
+    fi
+else
+  AC_MSG_NOTICE($crystalhd_disabled)
+  USE_CRYSTALHD=0
+fi
+
 # VTBDecoder
 if test "x$use_vtbdecoder" != "xno"; then
   if test "$host_vendor" = "apple" ; then
@@ -2087,6 +2132,12 @@ else
   final_message="$final_message\n  VAAPI:\tNo"
 fi
 
+if test "x$use_crystalhd" != "xno"; then
+  final_message="$final_message\n  CrystalHD:\tYes"
+else
+  final_message="$final_message\n  CrystalHD:\tNo"
+fi
+
 if test "x$use_vtbdecoder" != "xno"; then
   final_message="$final_message\n  VTBDecoder:\tYes"
 else
@@ -2618,6 +2669,7 @@ AC_SUBST(USE_OPENGL)
 AC_SUBST(USE_OPENGLES)
 AC_SUBST(USE_VDPAU)
 AC_SUBST(USE_VAAPI)
+AC_SUBST(USE_CRYSTALHD)
 AC_SUBST(USE_LIBSMBCLIENT)
 AC_SUBST(USE_LIBNFS)
 AC_SUBST(USE_AIRPLAY)
diff --git a/docs/README.linux b/docs/README.linux
index ee64baf..029ad2d 100644
--- a/docs/README.linux
+++ b/docs/README.linux
@@ -45,21 +45,24 @@ external libraries enabled).
 
 Build-Depends: autoconf, automake, autopoint, autotools-dev, cmake, curl,
   debhelper (>= 7.0.50~), default-jre, gawk, gperf, libao-dev, libasound2-dev,
-  libass-dev (>= 0.9.8), libavahi-client-dev, libavahi-common-dev, libbluetooth-dev,
-  libbluray-dev, libboost-dev, libboost-thread-dev, libbz2-dev, libcap-dev, libcdio-dev,
-  libcec-dev, libcurl4-gnutls-dev | libcurl4-openssl-dev | libcurl-dev, libcwiid-dev,
-  libdbus-1-dev, libfontconfig-dev, libfreetype6-dev, libfribidi-dev,
-  libgif-dev (>= 4.1.6), libgl1-mesa-dev | libgl-dev, libglew-dev, libglu1-mesa-dev | libglu-dev,
-  libiso9660-dev, libjasper-dev, libjpeg-dev, libltdl-dev, liblzo2-dev, libmicrohttpd-dev,
-  libmodplug-dev, libmpcdec-dev, libmpeg2-4-dev, libmysqlclient-dev, libnfs-dev, libogg-dev,
-  libpcre3-dev, libplist-dev, libpng12-dev | libpng-dev, libpulse-dev, librtmp-dev,libsdl2-dev,
-  libshairplay-dev, libsmbclient-dev, libsqlite3-dev, libssh-dev, libssl-dev, libswscale-dev,
-  libtag1-dev (>= 1.8), libtiff-dev, libtinyxml-dev (>= 2.6.2), libtool, libudev-dev,
-  libusb-dev, libva-dev, libvdpau-dev, libvorbis-dev, libxinerama-dev, libxml2-dev,
-  libxmu-dev, libxrandr-dev, libxslt1-dev, libxt-dev, libyajl-dev (>=2.0), lsb-release,
-  nasm [!amd64], python-dev, python-imaging, python-support, swig, unzip, yasm, zip,
-  zlib1g-dev
-  
+  libass-dev (>= 0.9.8), libavahi-client-dev, libavahi-common-dev, libavcodec-dev,
+  libavfilter-dev, libavformat-dev, libavutil-dev, libbluetooth-dev, libbluray-dev,
+  libboost-dev, libboost-thread-dev, libbz2-dev, libcap-dev, libcdio-dev, libcec-dev,
+  libcrystalhd-dev, libcurl4-gnutls-dev | libcurl4-openssl-dev | libcurl-dev,
+  libcwiid-dev, libdbus-1-dev, libenca-dev, libflac-dev, libfontconfig-dev,
+  libfreetype6-dev, libfribidi-dev, libgl1-mesa-dev | libgl-dev, libglew-dev, 
+  libglu1-mesa-dev | libglu-dev, libhal-dev, libhal-storage-dev, libiso9660-dev,
+  libjasper-dev, libjpeg-dev, libltdl-dev, liblzo2-dev, libmad0-dev, libmicrohttpd-dev,
+  libmodplug-dev, libmpcdec-dev, libmpeg2-4-dev, libmysqlclient-dev, libnfs-dev,
+  libogg-dev, libpcre3-dev, libplist-dev, libpng12-dev | libpng-dev, libpostproc-dev,
+  libpulse-dev, librtmp-dev, libsdl-dev, libsdl-image1.2-dev, libsdl-mixer1.2-dev,
+  libshairplay-dev, libsmbclient-dev, libsqlite3-dev, libssh-dev, libssl-dev, 
+  libswscale-dev, libtag1-dev (>= 1.8), libtiff-dev, libtinyxml-dev, libtool,
+  libudev-dev, libusb-dev, libva-dev, libvdpau-dev, libvorbis-dev, libxinerama-dev,
+  libxml2-dev, libxmu-dev, libxrandr-dev, libxslt1-dev, libxt-dev, libyajl-dev,
+  lsb-release, nasm [!amd64], python-dev, python-imaging, python-support, swig,
+  unzip, yasm, zip, zlib1g-dev
+
 Note: For developers and anyone else who compiles frequently it is recommended to use ccache.
 
    $ sudo apt-get install ccache
diff --git a/lib/win32/libcrystalhd/bc_dts_defs.h b/lib/win32/libcrystalhd/bc_dts_defs.h
new file mode 100644
index 0000000..c2a7c2d
--- /dev/null
+++ b/lib/win32/libcrystalhd/bc_dts_defs.h
@@ -0,0 +1,635 @@
+/********************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: bc_dts_defs.h
+ *
+ *  Description: Common definitions for all components. Only types
+ *		 is allowed to be included from this file.
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ ********************************************************************
+ * This header is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This header is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this header.  If not, see <http://www.gnu.org/licenses/>.
+ *******************************************************************/
+
+#ifndef _BC_DTS_DEFS_H_
+#define _BC_DTS_DEFS_H_
+
+#include "bc_dts_types.h"
+
+/* BIT Mask */
+#define BC_BIT(_x)		(1 << (_x))
+
+typedef enum _BC_STATUS {
+	BC_STS_SUCCESS		= 0,
+	BC_STS_INV_ARG		= 1,
+	BC_STS_BUSY		= 2,
+	BC_STS_NOT_IMPL		= 3,
+	BC_STS_PGM_QUIT		= 4,
+	BC_STS_NO_ACCESS	= 5,
+	BC_STS_INSUFF_RES	= 6,
+	BC_STS_IO_ERROR		= 7,
+	BC_STS_NO_DATA		= 8,
+	BC_STS_VER_MISMATCH	= 9,
+	BC_STS_TIMEOUT		= 10,
+	BC_STS_FW_CMD_ERR	= 11,
+	BC_STS_DEC_NOT_OPEN	= 12,
+	BC_STS_ERR_USAGE	= 13,
+	BC_STS_IO_USER_ABORT	= 14,
+	BC_STS_IO_XFR_ERROR	= 15,
+	BC_STS_DEC_NOT_STARTED	= 16,
+	BC_STS_FWHEX_NOT_FOUND	= 17,
+	BC_STS_FMT_CHANGE	= 18,
+	BC_STS_HIF_ACCESS	= 19,
+	BC_STS_CMD_CANCELLED	= 20,
+	BC_STS_FW_AUTH_FAILED	= 21,
+	BC_STS_BOOTLOADER_FAILED = 22,
+	BC_STS_CERT_VERIFY_ERROR = 23,
+	BC_STS_DEC_EXIST_OPEN	= 24,
+	BC_STS_PENDING		= 25,
+	BC_STS_CLK_NOCHG	= 26,
+
+	/* Must be the last one.*/
+	BC_STS_ERROR		= -1
+} BC_STATUS;
+
+/*------------------------------------------------------*
+ *    Registry Key Definitions				*
+ *------------------------------------------------------*/
+#define BC_REG_KEY_MAIN_PATH	"Software\\Broadcom\\MediaPC\\CrystalHD"
+#define BC_REG_KEY_FWPATH		"FirmwareFilePath"
+#define BC_REG_KEY_SEC_OPT		"DbgOptions"
+
+/*
+ * Options:
+ *
+ *  b[5] = Enable RSA KEY in EEPROM Support
+ *  b[6] = Enable Old PIB scheme. (0 = Use PIB with video scheme)
+ *
+ *  b[12] = Enable send message to NotifyIcon
+ *
+ */
+
+typedef enum _BC_SW_OPTIONS {
+	BC_OPT_DOSER_OUT_ENCRYPT	= BC_BIT(3),
+	BC_OPT_LINK_OUT_ENCRYPT		= BC_BIT(29),
+} BC_SW_OPTIONS;
+
+typedef struct _BC_REG_CONFIG{
+	uint32_t		DbgOptions;
+} BC_REG_CONFIG;
+
+#if defined(__KERNEL__) || defined(__LINUX_USER__)
+#else
+/* Align data structures */
+#define ALIGN(x)	__declspec(align(x))
+#endif
+
+/* mode
+ * b[0]..b[7]	= _DtsDeviceOpenMode
+ * b[8]		=  Load new FW
+ * b[9]		=  Load file play back FW
+ * b[10]	=  Disk format (0 for HD DVD and 1 for BLU ray)
+ * b[11]-b[15]	=  default output resolution
+ * b[16]	=  Skip TX CPB Buffer Check
+ * b[17]	=  Adaptive Output Encrypt/Scramble Scheme
+ * b[18]-b[31]	=  reserved for future use
+ */
+
+/* To allow multiple apps to open the device. */
+enum _DtsDeviceOpenMode {
+	DTS_PLAYBACK_MODE = 0,
+	DTS_DIAG_MODE,
+	DTS_MONITOR_MODE,
+	DTS_HWINIT_MODE
+};
+
+/* To enable the filter to selectively enable/disable fixes or erratas */
+enum _DtsDeviceFixMode {
+	DTS_LOAD_NEW_FW		= BC_BIT(8),
+	DTS_LOAD_FILE_PLAY_FW	= BC_BIT(9),
+	DTS_DISK_FMT_BD		= BC_BIT(10),
+	/* b[11]-b[15] : Default output resolution */
+	DTS_SKIP_TX_CHK_CPB	= BC_BIT(16),
+	DTS_ADAPTIVE_OUTPUT_PER	= BC_BIT(17),
+	DTS_INTELLIMAP		= BC_BIT(18),
+	/* b[19]-b[21] : select clock frequency */
+	DTS_PLAYBACK_DROP_RPT_MODE = BC_BIT(22),
+	DTS_DIAG_TEST_MODE = BC_BIT(23),
+	DTS_SINGLE_THREADED_MODE = BC_BIT(24),
+	DTS_FILTER_MODE = BC_BIT(25),
+	DTS_MFT_MODE = BC_BIT(26)
+};
+
+#define DTS_DFLT_RESOLUTION(x)	(x<<11)
+
+#define DTS_DFLT_CLOCK(x) (x<<19)
+
+/* F/W File Version corresponding to S/W Releases */
+enum _FW_FILE_VER {
+	/* S/W release: 02.04.02	F/W release 2.12.2.0 */
+	BC_FW_VER_020402 = ((12<<16) | (2<<8) | (0))
+};
+
+/*------------------------------------------------------*
+ *    Stream Types for DtsOpenDecoder()			*
+ *------------------------------------------------------*/
+enum _DtsOpenDecStreamTypes {
+	BC_STREAM_TYPE_ES		= 0,
+	BC_STREAM_TYPE_PES		= 1,
+	BC_STREAM_TYPE_TS		= 2,
+	BC_STREAM_TYPE_ES_TSTAMP	= 6,
+};
+
+/*------------------------------------------------------*
+ *    Video Algorithms for DtsSetVideoParams()		*
+ *------------------------------------------------------*/
+enum _DtsSetVideoParamsAlgo {
+	BC_VID_ALGO_H264		= 0,
+	BC_VID_ALGO_MPEG2		= 1,
+	BC_VID_ALGO_VC1			= 4,
+	BC_VID_ALGO_DIVX		= 6,
+	BC_VID_ALGO_VC1MP		= 7,
+};
+
+/*------------------------------------------------------*
+ *    MPEG Extension to the PPB				*
+ *------------------------------------------------------*/
+#define BC_MPEG_VALID_PANSCAN		(1)
+
+typedef struct _BC_PIB_EXT_MPEG {
+	uint32_t	valid;
+	/* Always valid,  defaults to picture size if no
+	 * sequence display extension in the stream. */
+	uint32_t	display_horizontal_size;
+	uint32_t	display_vertical_size;
+
+	/* MPEG_VALID_PANSCAN
+	 * Offsets are a copy values from the MPEG stream. */
+	uint32_t	offset_count;
+	int32_t		horizontal_offset[3];
+	int32_t		vertical_offset[3];
+
+} BC_PIB_EXT_MPEG;
+
+/*------------------------------------------------------*
+ *    H.264 Extension to the PPB			*
+ *------------------------------------------------------*/
+/* Bit definitions for 'other.h264.valid' field */
+#define H264_VALID_PANSCAN		(1)
+#define H264_VALID_SPS_CROP		(2)
+#define H264_VALID_VUI			(4)
+
+typedef struct _BC_PIB_EXT_H264 {
+	/* 'valid' specifies which fields (or sets of
+	 * fields) below are valid.  If the corresponding
+	 * bit in 'valid' is NOT set then that field(s)
+	 * is (are) not initialized. */
+	uint32_t	valid;
+
+	/* H264_VALID_PANSCAN */
+	uint32_t	pan_scan_count;
+	int32_t		pan_scan_left[3];
+	int32_t		pan_scan_right[3];
+	int32_t		pan_scan_top[3];
+	int32_t		pan_scan_bottom[3];
+
+	/* H264_VALID_SPS_CROP */
+	int32_t		sps_crop_left;
+	int32_t		sps_crop_right;
+	int32_t		sps_crop_top;
+	int32_t		sps_crop_bottom;
+
+	/* H264_VALID_VUI */
+	uint32_t	chroma_top;
+	uint32_t	chroma_bottom;
+
+} BC_PIB_EXT_H264;
+
+/*------------------------------------------------------*
+ *    VC1 Extension to the PPB				*
+ *------------------------------------------------------*/
+#define VC1_VALID_PANSCAN		(1)
+
+typedef struct _BC_PIB_EXT_VC1 {
+	uint32_t	valid;
+
+	/* Always valid, defaults to picture size if no
+	 * sequence display extension in the stream. */
+	uint32_t	display_horizontal_size;
+	uint32_t	display_vertical_size;
+
+	/* VC1 pan scan windows */
+	uint32_t	num_panscan_windows;
+	int32_t		ps_horiz_offset[4];
+	int32_t		ps_vert_offset[4];
+	int32_t		ps_width[4];
+	int32_t		ps_height[4];
+
+} BC_PIB_EXT_VC1;
+
+
+/*------------------------------------------------------*
+ *    Picture Information Block				*
+ *------------------------------------------------------*/
+#if defined(__LINUX_USER__) || defined(_WIN32)
+/* Values for 'pulldown' field.  '0' means no pulldown information
+ * was present for this picture. */
+enum {
+	vdecNoPulldownInfo	= 0,
+	vdecTop			= 1,
+	vdecBottom		= 2,
+	vdecTopBottom		= 3,
+	vdecBottomTop		= 4,
+	vdecTopBottomTop	= 5,
+	vdecBottomTopBottom	= 6,
+	vdecFrame_X2		= 7,
+	vdecFrame_X3		= 8,
+	vdecFrame_X1		= 9,
+	vdecFrame_X4		= 10,
+};
+
+/* Values for the 'frame_rate' field. */
+enum {
+	vdecFrameRateUnknown = 0,
+	vdecFrameRate23_97,
+	vdecFrameRate24,
+	vdecFrameRate25,
+	vdecFrameRate29_97,
+	vdecFrameRate30,
+	vdecFrameRate50,
+	vdecFrameRate59_94,
+	vdecFrameRate60,
+	vdecFrameRate14_985,
+	vdecFrameRate7_496,
+};
+
+/* Values for the 'aspect_ratio' field. */
+enum {
+	vdecAspectRatioUnknown = 0,
+	vdecAspectRatioSquare,
+	vdecAspectRatio12_11,
+	vdecAspectRatio10_11,
+	vdecAspectRatio16_11,
+	vdecAspectRatio40_33,
+	vdecAspectRatio24_11,
+	vdecAspectRatio20_11,
+	vdecAspectRatio32_11,
+	vdecAspectRatio80_33,
+	vdecAspectRatio18_11,
+	vdecAspectRatio15_11,
+	vdecAspectRatio64_33,
+	vdecAspectRatio160_99,
+	vdecAspectRatio4_3,
+	vdecAspectRatio16_9,
+	vdecAspectRatio221_1,
+	vdecAspectRatioOther = 255,
+};
+
+/* Values for the 'colour_primaries' field. */
+enum {
+	vdecColourPrimariesUnknown = 0,
+	vdecColourPrimariesBT709,
+	vdecColourPrimariesUnspecified,
+	vdecColourPrimariesReserved,
+	vdecColourPrimariesBT470_2M = 4,
+	vdecColourPrimariesBT470_2BG,
+	vdecColourPrimariesSMPTE170M,
+	vdecColourPrimariesSMPTE240M,
+	vdecColourPrimariesGenericFilm,
+};
+
+enum {
+	vdecRESOLUTION_CUSTOM	= 0x00000000, /* custom */
+	vdecRESOLUTION_480i	= 0x00000001, /* 480i */
+	vdecRESOLUTION_1080i	= 0x00000002, /* 1080i (1920x1080, 60i) */
+	vdecRESOLUTION_NTSC	= 0x00000003, /* NTSC (720x483, 60i) */
+	vdecRESOLUTION_480p	= 0x00000004, /* 480p (720x480, 60p) */
+	vdecRESOLUTION_720p	= 0x00000005, /* 720p (1280x720, 60p) */
+	vdecRESOLUTION_PAL1	= 0x00000006, /* PAL_1 (720x576, 50i) */
+	vdecRESOLUTION_1080i25	= 0x00000007, /* 1080i25 (1920x1080, 50i) */
+	vdecRESOLUTION_720p50	= 0x00000008, /* 720p50 (1280x720, 50p) */
+	vdecRESOLUTION_576p	= 0x00000009, /* 576p (720x576, 50p) */
+	vdecRESOLUTION_1080i29_97 = 0x0000000A, /* 1080i (1920x1080, 59.94i) */
+	vdecRESOLUTION_720p59_94  = 0x0000000B, /* 720p (1280x720, 59.94p) */
+	vdecRESOLUTION_SD_DVD	= 0x0000000C, /* SD DVD (720x483, 60i) */
+	vdecRESOLUTION_480p656	= 0x0000000D, /* 480p (720x480, 60p), output bus width 8 bit, clock 74.25MHz */
+	vdecRESOLUTION_1080p23_976 = 0x0000000E, /* 1080p23_976 (1920x1080, 23.976p) */
+	vdecRESOLUTION_720p23_976  = 0x0000000F, /* 720p23_976 (1280x720p, 23.976p) */
+	vdecRESOLUTION_240p29_97   = 0x00000010, /* 240p (1440x240, 29.97p ) */
+	vdecRESOLUTION_240p30	= 0x00000011, /* 240p (1440x240, 30p) */
+	vdecRESOLUTION_288p25	= 0x00000012, /* 288p (1440x288p, 25p) */
+	vdecRESOLUTION_1080p29_97 = 0x00000013, /* 1080p29_97 (1920x1080, 29.97p) */
+	vdecRESOLUTION_1080p30	= 0x00000014, /* 1080p30 (1920x1080, 30p) */
+	vdecRESOLUTION_1080p24	= 0x00000015, /* 1080p24 (1920x1080, 24p) */
+	vdecRESOLUTION_1080p25	= 0x00000016, /* 1080p25 (1920x1080, 25p) */
+	vdecRESOLUTION_720p24	= 0x00000017, /* 720p24 (1280x720, 25p) */
+	vdecRESOLUTION_720p29_97  = 0x00000018, /* 720p29.97 (1280x720, 29.97p) */
+	vdecRESOLUTION_480p23_976 = 0x00000019, /* 480p23.976 (720*480, 23.976) */
+	vdecRESOLUTION_480p29_97  = 0x0000001A, /* 480p29.976 (720*480, 29.97p) */
+	vdecRESOLUTION_576p25	= 0x0000001B, /* 576p25 (720*576, 25p) */
+	/* For Zero Frame Rate */
+	vdecRESOLUTION_480p0	= 0x0000001C, /* 480p (720x480, 0p) */
+	vdecRESOLUTION_480i0	= 0x0000001D, /* 480i (720x480, 0i) */
+	vdecRESOLUTION_576p0	= 0x0000001E, /* 576p (720x576, 0p) */
+	vdecRESOLUTION_720p0	= 0x0000001F, /* 720p (1280x720, 0p) */
+	vdecRESOLUTION_1080p0	= 0x00000020, /* 1080p (1920x1080, 0p) */
+	vdecRESOLUTION_1080i0	= 0x00000021, /* 1080i (1920x1080, 0i) */
+};
+
+/* Bit definitions for 'flags' field */
+#define VDEC_FLAG_EOS				(0x0004)
+
+#define VDEC_FLAG_FRAME				(0x0000)
+#define VDEC_FLAG_FIELDPAIR			(0x0008)
+#define VDEC_FLAG_TOPFIELD			(0x0010)
+#define VDEC_FLAG_BOTTOMFIELD			(0x0018)
+
+#define VDEC_FLAG_PROGRESSIVE_SRC		(0x0000)
+#define VDEC_FLAG_INTERLACED_SRC		(0x0020)
+#define VDEC_FLAG_UNKNOWN_SRC			(0x0040)
+
+#define VDEC_FLAG_BOTTOM_FIRST			(0x0080)
+#define VDEC_FLAG_LAST_PICTURE			(0x0100)
+
+#define VDEC_FLAG_PICTURE_META_DATA_PRESENT	(0x40000)
+
+#endif /* __LINUX_USER__ */
+
+typedef struct _BC_PIC_INFO_BLOCK {
+	/* Common fields. */
+	uint64_t	timeStamp;	/* Timestamp */
+	uint32_t	picture_number;	/* Ordinal display number  */
+	uint32_t	width;		/* pixels	    */
+	uint32_t	height;		/* pixels	    */
+	uint32_t	chroma_format;	/* 0x420, 0x422 or 0x444 */
+	uint32_t	pulldown;
+	uint32_t	flags;
+	uint32_t	frame_rate;
+	uint32_t	aspect_ratio;
+	uint32_t	colour_primaries;
+	uint32_t	picture_meta_payload;
+	uint32_t	sess_num;
+	uint32_t	ycom;
+	uint32_t	custom_aspect_ratio_width_height;
+	uint32_t	n_drop;	/* number of non-reference frames remaining to be dropped */
+
+	/* Protocol-specific extensions. */
+	union {
+		BC_PIB_EXT_H264	h264;
+		BC_PIB_EXT_MPEG	mpeg;
+		BC_PIB_EXT_VC1	 vc1;
+	} other;
+
+} BC_PIC_INFO_BLOCK, *PBC_PIC_INFO_BLOCK;
+
+/*------------------------------------------------------*
+ *    ProcOut Info					*
+ *------------------------------------------------------*/
+/* Optional flags for ProcOut Interface.*/
+enum _POUT_OPTIONAL_IN_FLAGS_{
+	/* Flags from App to Device */
+	BC_POUT_FLAGS_YV12	  = 0x01,	/* Copy Data in YV12 format */
+	BC_POUT_FLAGS_STRIDE	  = 0x02,	/* Stride size is valid. */
+	BC_POUT_FLAGS_SIZE	  = 0x04,	/* Take size information from Application */
+	BC_POUT_FLAGS_INTERLACED  = 0x08,	/* copy only half the bytes */
+	BC_POUT_FLAGS_INTERLEAVED = 0x10,	/* interleaved frame */
+	BC_POUT_FLAGS_STRIDE_UV	  = 0x20,	/* Stride size is valid (for UV buffers). */
+	BC_POUT_FLAGS_MODE	  = 0x40,	/* Take output mode from Application, overrides YV12 flag if on */
+
+	/* Flags from Device to APP */
+	BC_POUT_FLAGS_FMT_CHANGE  = 0x10000,	/* Data is not VALID when this flag is set */
+	BC_POUT_FLAGS_PIB_VALID	  = 0x20000,	/* PIB Information valid */
+	BC_POUT_FLAGS_ENCRYPTED	  = 0x40000,	/* Data is encrypted. */
+	BC_POUT_FLAGS_FLD_BOT	  = 0x80000,	/* Bottom Field data */
+};
+
+//Decoder Capability
+enum DECODER_CAP_FLAGS
+{
+	BC_DEC_FLAGS_H264		= 0x01,
+	BC_DEC_FLAGS_MPEG2		= 0x02,
+	BC_DEC_FLAGS_VC1		= 0x04,
+	BC_DEC_FLAGS_M4P2		= 0x08,	//MPEG-4 Part 2: Divx, Xvid etc.
+};
+
+#if defined(__KERNEL__) || defined(__LINUX_USER__)
+typedef BC_STATUS(*dts_pout_callback)(void  *shnd, uint32_t width, uint32_t height, uint32_t stride, void *pOut);
+#else
+typedef BC_STATUS(*dts_pout_callback)(void  *shnd, uint32_t width, uint32_t height, uint32_t stride, struct _BC_DTS_PROC_OUT *pOut);
+#endif
+
+/* Line 21 Closed Caption */
+/* User Data */
+#define MAX_UD_SIZE		1792	/* 1920 - 128 */
+
+typedef struct _BC_DTS_PROC_OUT {
+	uint8_t		*Ybuff;			/* Caller Supplied buffer for Y data */
+	uint32_t	YbuffSz;		/* Caller Supplied Y buffer size */
+	uint32_t	YBuffDoneSz;		/* Transferred Y datasize */
+
+	uint8_t		*UVbuff;		/* Caller Supplied buffer for UV data */
+	uint32_t	UVbuffSz;		/* Caller Supplied UV buffer size */
+	uint32_t	UVBuffDoneSz;		/* Transferred UV data size */
+
+	uint32_t	StrideSz;		/* Caller supplied Stride Size */
+	uint32_t	PoutFlags;		/* Call IN Flags */
+
+	uint32_t	discCnt;		/* Picture discontinuity count */
+
+	BC_PIC_INFO_BLOCK PicInfo;		/* Picture Information Block Data */
+
+	/* Line 21 Closed Caption */
+	/* User Data */
+	uint32_t	UserDataSz;
+	uint8_t		UserData[MAX_UD_SIZE];
+
+	void		*hnd;
+	dts_pout_callback AppCallBack;
+	uint8_t		DropFrames;
+	uint8_t		b422Mode;		/* Picture output Mode */
+	uint8_t		bPibEnc;		/* PIB encrypted */
+	uint8_t		bRevertScramble;
+	uint32_t	StrideSzUV;		/* Caller supplied Stride Size */
+
+} BC_DTS_PROC_OUT;
+
+typedef struct _BC_DTS_STATUS {
+	uint8_t		ReadyListCount;	/* Number of frames in ready list (reported by driver) */
+	uint8_t		FreeListCount;	/* Number of frame buffers free.  (reported by driver) */
+	uint8_t		PowerStateChange; /* Number of active state power transitions (reported by driver) */
+	uint8_t		reserved_[1];
+
+	uint32_t	FramesDropped;	/* Number of frames dropped.  (reported by DIL) */
+	uint32_t	FramesCaptured;	/* Number of frames captured. (reported by DIL) */
+	uint32_t	FramesRepeated;	/* Number of frames repeated. (reported by DIL) */
+
+	uint32_t	InputCount;	/* Times compressed video has been sent to the HW.
+					 * i.e. Successful DtsProcInput() calls (reported by DIL) */
+	uint64_t	InputTotalSize;	/* Amount of compressed video that has been sent to the HW.
+					 * (reported by DIL) */
+	uint32_t	InputBusyCount;	/* Times compressed video has attempted to be sent to the HW
+					 * but the input FIFO was full. (reported by DIL) */
+
+	uint32_t	PIBMissCount;	/* Amount of times a PIB is invalid. (reported by DIL) */
+
+	uint32_t	cpbEmptySize;	/* supported only for H.264, specifically changed for
+					 * SingleThreadedAppMode. Report size of CPB buffer available.
+					 * Reported by DIL */
+	uint64_t	NextTimeStamp;	/* TimeStamp of the next picture that will be returned
+					 * by a call to ProcOutput. Added for SingleThreadedAppMode.
+					 * Reported back from the driver */
+	uint8_t		TxBufData;
+
+	uint8_t		reserved__[3];
+
+	uint32_t	picNumFlags; /* Picture number and flags of the next picture to be delivered from the driver */
+
+	uint8_t		reserved___[8];
+
+} BC_DTS_STATUS;
+
+#define BC_SWAP32(_v)			\
+	((((_v) & 0xFF000000)>>24)|	\
+	  (((_v) & 0x00FF0000)>>8)|	\
+	  (((_v) & 0x0000FF00)<<8)|	\
+	  (((_v) & 0x000000FF)<<24))
+
+#define WM_AGENT_TRAYICON_DECODER_OPEN	10001
+#define WM_AGENT_TRAYICON_DECODER_CLOSE	10002
+#define WM_AGENT_TRAYICON_DECODER_START	10003
+#define WM_AGENT_TRAYICON_DECODER_STOP	10004
+#define WM_AGENT_TRAYICON_DECODER_RUN	10005
+#define WM_AGENT_TRAYICON_DECODER_PAUSE	10006
+
+#define MAX_COLOR_SPACES	3
+
+typedef enum _BC_OUTPUT_FORMAT {
+	MODE420			= 0x0,
+	MODE422_YUY2		= 0x1,
+	MODE422_UYVY		= 0x2,
+	OUTPUT_MODE420		= 0x0,
+	OUTPUT_MODE422_YUY2	= 0x1,
+	OUTPUT_MODE422_UYVY	= 0x2,
+	OUTPUT_MODE420_NV12	= 0x0,
+	OUTPUT_MODE_INVALID	= 0xFF,
+} BC_OUTPUT_FORMAT;
+
+typedef struct _BC_COLOR_SPACES_ {
+	BC_OUTPUT_FORMAT	OutFmt[MAX_COLOR_SPACES];
+	uint16_t		Count;
+} BC_COLOR_SPACES;
+
+
+typedef enum _BC_CAPS_FLAGS_ {
+	PES_CONV_SUPPORT	= 1,	/*Support PES Conversion*/
+	MULTIPLE_DECODE_SUPPORT	= 2	/*Support multiple stream decode*/
+} BC_CAPS_FLAGS;
+
+typedef struct _BC_HW_CAPABILITY_ {
+	BC_CAPS_FLAGS		flags;
+	BC_COLOR_SPACES		ColorCaps;
+	void*			Reserved1;	/* Expansion Of API */
+
+	//Decoder Capability
+	uint32_t		DecCaps;	//DECODER_CAP_FLAGS
+} BC_HW_CAPS, *PBC_HW_CAPS;
+
+typedef struct _BC_SCALING_PARAMS_ {
+	uint32_t	sWidth;
+	uint32_t	sHeight;
+	uint32_t	DNR;
+	uint32_t	Reserved1;	/*Expansion Of API*/
+	uint8_t		*Reserved2;	/*Expansion OF API*/
+	uint32_t	Reserved3;	/*Expansion Of API*/
+	uint8_t		*Reserved4;	/*Expansion Of API*/
+
+} BC_SCALING_PARAMS, *PBC_SCALING_PARAMS;
+
+typedef enum _BC_MEDIA_SUBTYPE_ {
+	BC_MSUBTYPE_INVALID = 0,
+	BC_MSUBTYPE_MPEG1VIDEO,
+	BC_MSUBTYPE_MPEG2VIDEO,
+	BC_MSUBTYPE_H264,
+	BC_MSUBTYPE_WVC1,
+	BC_MSUBTYPE_WMV3,
+	BC_MSUBTYPE_AVC1,
+	BC_MSUBTYPE_WMVA,
+	BC_MSUBTYPE_VC1,
+	BC_MSUBTYPE_DIVX,
+	BC_MSUBTYPE_DIVX311,
+	BC_MSUBTYPE_OTHERS	/*Types to facilitate PES conversion*/
+} BC_MEDIA_SUBTYPE;
+
+typedef struct _BC_INPUT_FORMAT_ {
+	BOOL        FGTEnable;      /*Enable processing of FGT SEI*/
+	BOOL        MetaDataEnable; /*Enable retrieval of picture metadata to be sent to video pipeline.*/
+	BOOL        Progressive;    /*Instruct decoder to always try to send back progressive
+				     frames. If input content is 1080p, the decoder will
+				     ignore pull-down flags and always give 1080p output.
+				     If 1080i content is processed, the decoder will return
+				     1080i data. When this flag is not set, the decoder will
+				     use pull-down information in the input stream to decide
+				     the decoded data format.*/
+	uint32_t    OptFlags;       /*In this field bits 0:3 are used pass default frame rate, bits 4:5 are for operation mode
+				     (used to indicate Blu-ray mode to the decoder) and bit 6 is for the flag mpcOutPutMaxFRate
+				     which when set tells the FW to output at the max rate for the resolution and ignore the
+				     frame rate determined from the stream. Bit 7 is set to indicate that this is single threaded
+				     mode and the driver will be peeked to get timestamps ahead of time*/
+	BC_MEDIA_SUBTYPE mSubtype;  /* Video Media Type*/
+	uint32_t    width;
+	uint32_t    height;
+	uint32_t    startCodeSz;    /*Start code size for H264 clips*/
+	uint8_t     *pMetaData;     /*Metadata buffer that is used to pass sequence header*/
+	uint32_t    metaDataSz;     /*Metadata size*/
+	uint8_t     bEnableScaling;
+	BC_SCALING_PARAMS ScalingParams;
+} BC_INPUT_FORMAT;
+
+typedef struct _BC_INFO_CRYSTAL_ {
+	uint8_t device;
+	union {
+		struct {
+			uint32_t dilRelease:8;
+			uint32_t dilMajor:8;
+			uint32_t dilMinor:16;
+		};
+		uint32_t version;
+	} dilVersion;
+
+	union {
+		struct {
+			uint32_t drvRelease:4;
+			uint32_t drvMajor:8;
+			uint32_t drvMinor:12;
+			uint32_t drvBuild:8;
+		};
+		uint32_t version;
+	} drvVersion;
+
+	union {
+		struct {
+			uint32_t fwRelease:4;
+			uint32_t fwMajor:8;
+			uint32_t fwMinor:12;
+			uint32_t fwBuild:8;
+		};
+		uint32_t version;
+	} fwVersion;
+
+	uint32_t Reserved1; // For future expansion
+	uint32_t Reserved2; // For future expansion
+} BC_INFO_CRYSTAL, *PBC_INFO_CRYSTAL;
+
+#endif	/* _BC_DTS_DEFS_H_ */
diff --git a/lib/win32/libcrystalhd/bc_dts_types.h b/lib/win32/libcrystalhd/bc_dts_types.h
new file mode 100644
index 0000000..a0b9ca5
--- /dev/null
+++ b/lib/win32/libcrystalhd/bc_dts_types.h
@@ -0,0 +1,68 @@
+/********************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: bc_dts_types.h
+ *
+ *  Description: Data types
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ ********************************************************************
+ * This header is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This header is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this header.  If not, see <http://www.gnu.org/licenses/>.
+ *******************************************************************/
+
+#ifndef _BC_DTS_TYPES_H_
+#define _BC_DTS_TYPES_H_
+
+#ifdef __LINUX_USER__  /* Don't include these for KERNEL.. */
+#include <stdint.h>
+#endif
+
+#ifndef PVOID
+typedef void	*PVOID;
+#endif
+
+#ifndef BOOL
+typedef int	BOOL;
+#endif
+
+#ifdef __LINUX_USER__	/* Don't include these for KERNEL */
+typedef uint32_t	ULONG;
+typedef int32_t		LONG;
+typedef void		*HANDLE;
+#ifndef VOID
+typedef void		VOID;
+#endif
+typedef void		*LPVOID;
+typedef uint32_t	DWORD;
+typedef uint32_t	UINT32;
+typedef uint32_t	*LPDWORD;
+typedef unsigned char	*PUCHAR;
+
+#ifndef TRUE
+	#define TRUE		1
+#endif
+
+#ifndef FALSE
+	#define FALSE		0
+#endif
+
+#else /* !__LINUX_USER__ */
+
+/* For Kernel usage.. */
+typedef bool	bc_bool_t;
+#endif /* __LINUX_USER__ */
+
+#endif
+
diff --git a/lib/win32/libcrystalhd/libcrystalhd_if.h b/lib/win32/libcrystalhd/libcrystalhd_if.h
new file mode 100644
index 0000000..8807842
--- /dev/null
+++ b/lib/win32/libcrystalhd/libcrystalhd_if.h
@@ -0,0 +1,1539 @@
+/*****************************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: libcrystalhd_if.h
+ *
+ *  Description: Device Interface Library API.
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ *****************************************************************************
+ *
+ * This file is part of libcrystalhd.
+ *
+ * This library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ ****************************************************************************/
+
+#ifndef _BCM_LDIL_IF_H_
+#define _BCM_LDIL_IF_H_
+
+#include "bc_dts_defs.h"
+
+#define FLEA_MAX_TRICK_MODE_SPEED	6
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+******************************************************************************
+
+                            Theory of operation
+
+
+    The Device Interface Library (DIL) allows application level code, such
+as a DirectShow filter, to access the Broadcom CrystalHD decoder driver to 
+provide hardware decoding for MPEG-2, H.264 (AVC) and VC-1 streams.
+
+    In the Microsoft DirectShow system, the overall system graph would look 
+like the following:
+
++--------+  +---------------+  +---------------+  +--------------------+
+| Source |->| Demultiplexer |->| Audio decoder |->| DirectSound Device |
++--------+  +---------------+  +---------------+  +--------------------+
+                    |
+                    |  +-------------------------+  +----------------+
+                    +->| Broadcom decoder filter |->| Video Renderer |
+                       +-------------------------+  +----------------+
+                                  |    |  
+                            +----------------+
+                            |  Broadcom DIL  |
+                            +----------------+
+                                  |    |
+                            +-----------------+
+                            | Broadcom Driver |
+                            +-----------------+
+
+    From the view of the caller, the DIL will accept compressed video streams
+and will output decoded video frames or fields to seperate Y and UV buffers.
+The DIL is responsible solely for decoding video and has no responsibilities
+for audio nor for rendering, as shown in the above diagram.  Audio/video
+sychronization is assisted by feeding the DIL with timestamps so that it
+may pass those timestamps along with the decoded video.  The timestamped
+output video will then be presented at the appropriate time by the renderer.
+
+A minimal implementation would be:
+
+    HANDLE              hBRCMhandle;
+    uint8_t             input_buffer[INPUT_SIZE];
+    uint8_t             y_output_buffer[WIDTH*HEIGHT];
+    uint8_t             uv_output_buffer[WIDTH*HEIGHT];
+    BC_DTS_PROC_OUT     sProcOutData = { fill in your values here };
+    BC_PIC_INFO_BLOCK   sPIB = { fill in your values here };
+
+    // Acquire handle for device.
+    DtsDeviceOpen(&hBRCMhandle, 0);
+     
+    // Elemental stream.
+    DtsOpenDecoder(hBRCMhandle, 0);
+    
+    // H.264, Enable FGT SEI, do not parse metadata, no forced progressive out
+    DtsSetVideoParams(hBRCMhandle,0,1,0,0,0);
+
+    // Tell decoder to wait for input from host. (PC)
+    DtsStartDecoder(hBRCMhandle);       
+
+    // Input buffer address, input buffer size, no timestamp, Unencrypted
+    DtsProcInput(hBRCMhandle,input_buffer,sizeof(input_buffer),0,0);
+
+    // Tell PC to wait for data from decoder.
+    DtsStartCapture(hBRCMhandle);       
+
+    // 16ms timeout, pass pointer to PIB then get the decoded picture.
+    DtsProcOutput(hBRCMhandle,16,&sPIB);
+
+    // Stop the decoder.
+    DtsStopDecoder(hBRCMhandle);
+
+    // Close the decoder
+    DtsCloseDecoder(hBRCMhandle);
+
+    // Release handle for device.
+    DtsDeviceClose(hBRCMhandle);
+
+******************************************************************************
+*****************************************************************************/
+
+#define DRVIFLIB_API
+
+/*****************************************************************************
+Function name:
+
+    DtsDeviceOpen
+
+Description:
+
+    Opens a handle to the decoder device that will be used to address that
+    unique instance of the decoder for all subsequent operations.
+
+    Must be called once when the application opens the decoder for use.
+
+Parameters:
+
+    *hDevice    Pointer to device handle that will be filled in after the
+                device is successfully opened. [OUTPUT]
+
+    mode        Controls the mode in which the device is opened.
+                Currently only mode 0 (normal playback) is supported.
+                All other values will return BC_STS_INV_ARG.
+
+Return:
+
+    Returns BC_STS_SUCCESS or error codes as appropriate.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsDeviceOpen(
+    HANDLE   *hDevice,
+    uint32_t mode
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsDeviceClose
+
+Description:
+
+    Close the handle to the decoder device.
+
+    Must be called once when the application closes the decoder after use.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+
+Return:
+
+    Returns BC_STS_SUCCESS or error codes as appropriate.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsDeviceClose(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetVersion
+
+Description:
+
+    Get version information from the driver as well as API library.
+    Version numbers are maintained in <Major>.<Minor>.<Revision> format.
+    Example ?01.23.4567
+
+    The device must have been previously opened for this call to succeed.
+    The individual components of the revision number are available as follows:
+
+    o Major     (8 Bits) : Bit 31 ?24
+    o Minor     (8 Bits) : Bit 23 ?16
+    o Revision (16 Bits) : Bits 15 ?Bit 0.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+    DrVer       Device driver version
+    DilVer      Driver interface library version
+
+Return:
+    The revision numbers from the currently loaded driver as well as the
+    driver interface API library.
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetVersion(
+    HANDLE   hDevice,
+    uint32_t *DrVer,
+    uint32_t *DilVer
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetFWVersionFromFile
+
+Description:
+
+    Get version information from the Firmware Bin file when FW is not running
+    Version numbers in FW are maintained in <Major>.<Minor>.<Spl Revision> format.
+    the return value will be of the format:
+    (Major << 16) | (Minor<<8) | Spl_rev ?012345
+
+    The individual components of the revision number are available as follows:
+
+    o Major     (8 Bits) : Bit 24 ?16
+    o Minor     (8 Bits) : Bit 16 ?8
+    o Revision (16 Bits) : Bits 8 ?0.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+    StreamVer   Stream FW version
+    DecVer      VDEC FW version
+    Rsvd        Reserved for future use
+
+Return:
+    The Stream FW Version umbers from the FW bin file in the install directory
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetFWVersionFromFile(
+    HANDLE   hDevice,
+    uint32_t *StreamVer,
+    uint32_t *DecVer,
+    char     *fname
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetFWVersion
+
+Description:
+
+    Get version information from the Firmware. The version information is obtained
+    from Bin file when the flag is not set. When the flag is set, a FW command is
+    issued to get the version numbers.
+    Version numbers in FW are maintained in <Major>.<Minor>.<Spl Revision> format.
+    Version number will be returned in the following format
+    (Major << 16) | (Minor<<8) | Spl_rev ?012345
+
+    The individual components of the revision number are available as follows:
+
+    o Major     (8 Bits) : Bit 24 ?16
+    o Minor     (8 Bits) : Bit 16 ?8
+    o Revision (16 Bits) : Bits 8 ?Bit 0.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+    StreamVer   Stream FW version
+    DecVer      VDEC FW version
+    HwVer       Hardware version
+    Rsvd        Reserved for future use
+    flag        Reseved for future use
+
+Return:
+    The Stream FW Version number, VDEC FW version and Hwrev
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetFWVersion(
+    HANDLE   hDevice,
+    uint32_t *StreamVer,
+    uint32_t *DecVer,
+    uint32_t *HwVer,
+    char     *fname,
+    uint32_t flag
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsOpenDecoder
+
+Description:
+
+    Open the decoder for playback operations and sets appropriate parameters
+    for decode of input video data.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    StreamType  Currently supported streams are:
+                        Elementary Streams with no timestamp management (0)
+                        Transport Streams (2)
+                        Elementary Streams with timestamp management (6)
+                All other values will return BC_STS_INV_ARG.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsOpenDecoder(
+    HANDLE   hDevice,
+    uint32_t StreamType
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsCloseDecoder
+
+Description:
+
+    Close the decoder. No further pictures will be produced and all input
+    will be ignored.
+
+    The device must have been previously opened for this call to succeed.
+    This function closes the decoder and cleans up the state of the driver
+    and the library. All pending pictures will be dropped and all outstanding
+    transfers to and from the decoder will be aborted.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsCloseDecoder(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsStartDecoder
+
+Description:
+
+    Start the actual processing of input data. Before this command the
+    decoder will ignore all of the presented input data.
+
+    DtsOpenDecoder must always be followed by a DtsStartDecoder for the
+    decoder to start processing input data. The device must have been
+    previously opened for this call to succeed. In addition the video
+    parameters for codec must have been set via a call to DtsSetVideoParams.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStartDecoder(
+    HANDLE hDevice
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetVideoParams
+
+Description:
+
+    Sets various codec parameters that would be used by a subsequent call
+    to DtsStartDecoder.
+
+    DtsSetVideoParams must always be called before DtsStartDecoder for the
+    decoder to start processing input data. The device must have been
+    previously opened for this call to succeed.
+
+Parameters:
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    videoAlg        Video Codec to be enabled to decode stream.
+                    H.264 (0), VC-1 (4) and MPEG-2 (1) currently supported.
+                    All other values will return BC_STS_INV_ARG
+    FGTEnable       Enable processing of FGT SEI.
+    MetaDataEnable  Enable retrieval of picture metadata to be sent to video
+                    pipeline.
+    Progressive     Instruct decoder to always try to send back progressive
+                    frames. If input content is 1080p, the decoder will
+                    ignore pull-down flags and always give 1080p output.
+                    If 1080i content is processed, the decoder will return
+                    1080i data. When this flag is not set, the decoder will
+                    use pull-down information in the input stream to decide
+                    the decoded data format.
+    OptFlags        In this field bits 0:3 are used pass default frame rate,
+                    bits 4:5 are for operation mode (used to indicate Blu-ray
+                    mode to the decoder) and bit 6 is for the flag mpcOutPutMaxFRate
+                    which when set tells the FW to output at the max rate for the
+                    resolution and ignore the frame rate determined from the
+                    stream. Bit 7 is set to indicate that this is single threaded mode
+                    and the driver will be peeked to get timestamps ahead of time.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetVideoParams(
+    HANDLE   hDevice,
+    uint32_t videoAlg,
+    BOOL     FGTEnable,
+    BOOL     MetaDataEnable,
+    BOOL     Progressive,
+    uint32_t OptFlags
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetInputFormat
+    
+Description:
+
+    Sets input video's various parameters that would be used by a subsequent call
+    to DtsStartDecoder.
+
+    DtsSetInputFormat must always be called before DtsOpenDecoder for the
+    decoder to start processing input data. The device must have been
+    previously opened for this call to succeed.
+
+Parameters:
+    hDevice         Handle to device. This is obtained via a prior call to DtsDeviceOpen.
+    pInputFormat Pointer to the BC_INPUT_FORMAT data.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetInputFormat(
+    HANDLE  			hDevice,
+    BC_INPUT_FORMAT   *pInputFormat
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetVideoParams
+
+Description:
+
+    Returns various codec parameters that would be used by a subsequent call
+    to DtsStartDecoder. These parameters are either default values or were
+    set via a prior call to DtsSetVideoParams
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    *videoAlg       See DtsSetVideoParams. [OUTPUT]
+    *FGTEnable      See DtsSetVideoParams. [OUTPUT]
+    *MetaDataEnable See DtsSetVideoParams. [OUTPUT]
+    *Progressive    See DtsSetVideoParams. [OUTPUT]
+    Reserved        This field is reserved for possible future expansion.
+                    Set to 0.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetVideoParams(
+    HANDLE   hDevice,
+    uint32_t *videoAlg,
+    BOOL     *FGTEnable,
+    BOOL     *MetaDataEnable,
+    BOOL     *Progressive,
+    uint32_t Reserved
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsFormatChange
+
+Description:
+
+    Changes codec type and parameters.
+
+    The device must have been previously opened for this call to succeed.
+    This function should be used only for mid-stream format changes.
+    DtsStartDecoder must have been called before for this function to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    videoAlg    Video Codec to be enabled to decode stream.
+                H.264 (0), VC-1 (4) and MPEG-2 (1) currently supported. All
+                other values will return BC_STS_INV_ARG
+    FGTEnable   Enable processing of FGT SEI.
+    Progressive Instruct decoder to always try to send back progressive
+                frames. If input content is 1080p, the decoder will ignore
+                pull-down flags and always give 1080p output. If 1080i
+                content is processed, the decoder will return 1080i data.
+                When this flag is not set, the decoder will use pull-down
+                information in the input stream to decide the decoded data
+                format.
+    Reserved    This field is reserved for possible future expansion.
+                Set to 0.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsFormatChange(
+    HANDLE   hDevice,
+    uint32_t videoAlg,
+    BOOL     FGTEnable,
+    BOOL     MetaDataEnable,
+    BOOL     Progressive,
+    uint32_t Reserved
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsStopDecoder
+
+Description:
+
+    Stop the decoder.
+
+    The device must have been previously opened for this call to succeed.
+    This function will clean up any pending operations and stop the decoder.
+    Internal state is still maintained and the decoder can be restarted.
+    Any pending pictures will be dropped.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStopDecoder(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsPauseDecoder
+
+Description:
+
+    Pause the decoder. The paused picture will be repeated by decoder.
+
+    The device must have been previously opened for this call to succeed.
+    In addition the decoder must have been started as well. If the decoder
+    is open but not started, this function will return BC_STS_DEC_NOT_STARTED.
+    If the decoder has not been opened this function will return
+    BC_STS_DEC_NOT_OPEN.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsPauseDecoder(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsResumeDecoder
+
+Description:
+
+    Unpause the decoder from a previous paused condition.
+
+    The device must have been previously opened for this call to succeed.
+    If the decoder was not paused previously, this function will return
+    without affecting the decoder with a BC_STS_SUCCESS status. If the
+    decoder is open but not started, this function will return
+    BC_STS_DEC_NOT_STARTED.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsResumeDecoder(
+    HANDLE  hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetVideoPID
+    
+Description:
+
+    Sets the video PID in the input Transport Stream that the decoder
+    needs to process.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice Handle to device. This is obtained via a prior call to
+            DtsDeviceOpen.
+    PID     PID value that decoder needs to process.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetVideoPID(
+    HANDLE    hDevice,
+    uint32_t  pid
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    StartCaptureImmidiate
+    
+Description:
+
+    Instruct the driver to start capturing decoded frames for output.
+
+    The device must have been previously opened for this call to succeed.
+    This function must be called before the first call to DtsProcInput.
+    This function instructs the receive path in the driver to start waiting
+    for valid data to be presented from the decoder.
+
+Parameters:
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsStartCaptureImmidiate(
+    HANDLE    hDevice,
+    uint32_t  Reserved
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    StartCapture
+
+Description:
+
+    Instruct the driver to start capturing decoded frames for output.
+
+    The device must have been previously opened for this call to succeed.
+    This function must be called before the first call to DtsProcInput.
+    This function instructs the receive path in the driver to start waiting
+    for valid data to be presented from the decoder.
+
+Parameters:
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStartCapture(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    FlushRxCapture
+
+Description:
+
+    ***This function is deprecated and is for temporary use only.***
+
+    Flush the driverís queue of pictures and stops the capture process. These
+    functions will be replaced with automatic Stop (End of Sequence) detection.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsFlushRxCapture(
+    HANDLE hDevice,
+    BOOL   bDiscardOnly
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsProcOutput
+
+Description:
+
+    Returns one decoded picture to the caller.
+
+    The device must have been previously opened for this call to succeed.
+
+    == NOTE ====
+        For PIB AND 100% output encryption/scrambling on Bcm LINK hardware
+    use ProcOutputNoCopy() Interace. This interface will not support
+    PIB encryption.
+
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    milliSecWait    Timeout parameter. DtsProcOutput will fail is no picture
+                    is received in this time.
+    *pOut           This is a pointer to the BC_DTS_PROC_OUT structure that is
+                    allocated by the caller. The decoded picture is returned
+                    in this structure. This structure is described in the
+                    data structures section. The actual data buffer to be
+                    filled with the decoded data is allocated by the caller.
+                    Data is copied from the decoder to the buffers before this
+                    function returns. [INPUT/OUTPUT]
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsProcOutput(
+    HANDLE   hDevice,
+    uint32_t milliSecWait,
+    BC_DTS_PROC_OUT *pOut
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsProcOutputNoCopy
+
+Description:
+
+    Returns one decoded picture to the caller. Functionality of this API()
+    is very similar to ProcOutPut() API. This API will not copy the video data
+    to caller's buffers but provides the source buffer pointers in pOut structure.
+
+    This is more secure and preferred method for BCM's Link hardware. The actual
+    format conversion/copy routines are provided as part of the Filter/Security
+    layer source code. Using this method, all the clear data handling will be
+    done by bcmDFilter or bcmSec layers which are expected to be in Player's
+    tamper resistant area.
+
+    == NOTE ====
+     1) DtsReleaseOutputBuffs() interface must be called to release the buffers
+        back to DIL if return Status is BC_STS_SUCCESS.
+
+     2) Only this interface supports PIB and full 100% output encryption/Scrambling.
+
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    milliSecWait    Timeout parameter. DtsProcOoutput will fail is no picture
+                    is received in this time.
+    *pOut           This is a pointer to the BC_DTS_PROC_OUT structure that is
+                    allocated by the caller. The decoded picture is returned
+                    in this structure.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsProcOutputNoCopy(
+    HANDLE   hDevice,
+    uint32_t milliSecWait,
+    BC_DTS_PROC_OUT *pOut
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsReleaseOutputBuffs
+
+Description:
+
+    Release Buffers acquired during ProcOutputNoCopy() interface.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    Reserved        Reserved. Set to NULL.
+
+    fChange         FALSE.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsReleaseOutputBuffs(
+    HANDLE hDevice,
+    PVOID  Reserved,
+    BOOL   fChange
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsProcInput
+
+Description:
+
+    Sends compressed (coded) data to the decoder for processing.
+
+    The device must have been previously opened for this call to succeed.
+    In addition, suitable keys must have been exchanged for decryption and
+    decode to be successful.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    pUserData   Pointer to data buffer that holds the data to be transferred.
+                [INPUT]
+    sizeInBytes Size in Bytes of data available to be sent to the decoder for
+                processing.
+    Timestamp   Optional timestamp information attached to the media sample
+                that is available in the buffer. If timestamp is present
+                (i.e. non-zero), then this will be reflected in the output
+                sample (picture) produced from the contents of this buffer.
+				Timestamp should be in units of 100 ns.
+    Encrypted   Flag to indicate that the data transfer is not in the clear
+                and that the decoder needs to decrypt before it can decode
+                the data.  Note that due to complexity, it is preferred that
+                the application writer uses the higher level
+                dts_pre_proc_input() call if encypted content will be sent.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsProcInput(
+    HANDLE   hDevice,
+    uint8_t  *pUserData,
+    uint32_t ulSizeInBytes,
+    uint64_t timeStamp,
+    BOOL     encrypted
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetColorPrimaries
+
+Description:
+
+    Returns color primaries information from the stream being processed.
+
+    The device must have been previously opened for this call to succeed.
+    In addition at least one picture must have been successfully decoded and
+    returned back from the decoder.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    colorPrimaries  Pointer to U32 to receive the color primaries information.
+                    The values returned are described in the previous section
+                    regarding the picture metadata. [OUTPUT]
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetColorPrimaries(
+    HANDLE    hDevice,
+    uint32_t  *colorPrimaries
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsFlushInput
+
+Description:
+
+    Flushes the current channel and causes the decoder to stop accessing input
+    data.  Based on the flush mode parameter, the channel will be flushed from
+    the current point in the input data or from the current processing point.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    Mode            0   Flush at the current input point. use to drain the
+                        input FIFO . All the data that has been received will
+                        be decoded.
+                    1   Flush at the current processing point. All the decoded
+                        frames will be presented but no more data from the
+                        input will be decoded.
+                    2   Flushes all the decoder buffers, input, decoded and
+                        to be decoded.
+                    3   Cancels the pending TX Request from the DIL/driver
+					4	Flushes all the decoder buffers, input, decoded and
+						to be decoded data. Also flushes the drivers buffers
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsFlushInput(
+    HANDLE   hDevice,
+    uint32_t Mode
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetRateChange
+
+Description:
+
+    Sets the decoder playback speed and direction of playback.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    rate            Inverse of speed x 10000.
+                    Examples:
+                        1/2x playback speed = 20000
+                        1x   playback speed = 10000
+                        2x   playback speed = 5000
+
+    direction       Playback direction.
+                    0   Forward direction.
+                    1   Reverse direction.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetRateChange(
+    HANDLE   hDevice,
+    uint32_t rate,
+    uint8_t  direction
+    );
+
+
+//Set FF Rate for Catching Up
+/*****************************************************************************
+
+Function name:
+
+    DtsSetFFRate
+
+Description:
+
+    Sets the decoder playback FF speed
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    rate            Inverse of speed x 10000.
+                    Examples:
+                        1/2x playback speed = 20000
+                        1x   playback speed = 10000
+                        2x   playback speed = 5000
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetFFRate(
+    HANDLE   hDevice,
+    uint32_t rate
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetSkipPictureMode
+
+Description:
+
+    This command sets the decoder to only decode selected picture types.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+    SkipMode        0   IPB, All pictures are decoded.
+
+                    1   IP decoding, This mode skips all non reference pictures.
+
+                    2   I decoding, This mode skips all P/B pictures and only decodes
+                        I pictures.
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetSkipPictureMode(
+    HANDLE   hDevice,
+    uint32_t SkipMode
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetIFrameTrickMode
+
+Description:
+
+    This command sets the decoder to decode only I Frames for FF and FR.
+
+    Use this API for I Frame only trick mode play back in either direction. The
+    application/Up stream filter  determines the speed of the playback by
+    means of Skip on the input compressed data.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetIFrameTrickMode(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsStepDecoder
+
+Description:
+
+    This function forwards one frame.
+
+    The device must have been opened must be in paused
+    state previously for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStepDecoder(
+    HANDLE hDevice
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsIs422Supported
+
+Description:
+
+    This function returns whether 422 YUV mode is supported or not.
+
+    The device must have been opened previously for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    bSupported  1 - 422 is supported
+                0 - 422 is not supported.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsIs422Supported(
+    HANDLE  hDevice,
+    uint8_t *bSupported
+    );
+
+/*****************************************************************************
+
+Function name:
+
+     DtsSetColorSpace    
+    
+Description:
+
+    This function sets the output sample's color space.
+
+    The device must have been opened previously and must support 422 mode for
+    this call to succeed.
+
+    Use "DtsIs422Supported" to find whether 422 mode is supported.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    422Mode     Mode is defined by BC_OUTPUT_FORMAT as follows -
+				OUTPUT_MODE420		= 0x0,
+				OUTPUT_MODE422_YUY2	= 0x1,
+				OUTPUT_MODE422_UYVY	= 0x2,
+				OUTPUT_MODE_INVALID	= 0xFF
+				Valid values for this API are OUTPUT_MODE422_YUY2 and OUTPUT_MODE422_UYVY
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetColorSpace(
+    HANDLE  hDevice,
+    BC_OUTPUT_FORMAT      Mode422
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSet422Mode
+
+Description:
+
+    This function sets the 422 mode to either YUY2 or UYVY.
+
+    The device must have been opened previously and must support 422 mode for
+    this call to succeed.
+
+    Use "DtsIs422Supported" to find whether 422 mode is supported.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    422Mode     0 - set the YUV mode to YUY2
+                1 - set the YUV mode to UYVY
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSet422Mode(
+    HANDLE  hDevice,
+    uint8_t Mode422
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetDILPath
+
+Description:
+
+    This is a helper function to return DIL's Path.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+    DilPath     Buffer to hold DIL path info upto 256 bytes.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+
+DRVIFLIB_API BC_STATUS
+DtsGetDILPath(
+    HANDLE   hDevice,
+    char   *DilPath,
+    uint32_t size
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsDropPictures
+
+Description:
+
+    This command sets the decoder to skip one or more non-reference (B) pictures
+    in the input data stream.  This is used for when the audio is ahead of
+    video and the application needs to cause video to move ahead to catch up.
+    Reference pictures are not skipped.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+    Pictures        The number of non-reference pictures to drop.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsDropPictures(
+    HANDLE   hDevice,
+    uint32_t Pictures
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetDriverStatus
+
+Description:
+
+    This command returns various statistics related to the driver and DIL.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+    *pStatus        Pointer to BC_DTS_STATUS to receive driver status.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetDriverStatus(
+    HANDLE          hDevice,
+	BC_DTS_STATUS   *pStatus
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetCapabilities
+
+Description:
+
+    This command returns output format support and hardware capabilities.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    pCapsBuffer   Pointer to BC_HW_CAPS to receive HW Output capabilities.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsGetCapabilities (
+	HANDLE  hDevice,
+	PBC_HW_CAPS	pCapsBuffer
+	);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetScaleParams
+
+Description:
+
+    This command sets hardware scaling parameters.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    pScaleParams   Pointer to BC_SCALING_PARAMS to set hardware scaling parameters.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetScaleParams (
+	HANDLE  hDevice,
+	PBC_SCALING_PARAMS pScaleParams
+	);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsIsEndOfStream
+
+Description:
+
+    This command returns whether the end of stream(EOS) is reaching.
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    bEOS   Pointer to uint8_t to indicate if EOS of not
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsIsEndOfStream(
+    HANDLE  hDevice,
+    uint8_t*	bEOS
+);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsCrystalHDVersion
+
+Description:
+
+    This API returns hw and sw version information for Crystal HD solutions
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    bCrystalInfo   Pointer to structure to fill in with information
+
+	device = 0 for BCM70012, 1 for BCM70015
+	
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsCrystalHDVersion(
+    HANDLE  hDevice,
+    PBC_INFO_CRYSTAL bCrystalInfo
+);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsTxFreeSize
+
+Description:
+
+    This API returns the amount of free space in the tx circular buffer
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+Return:
+
+    uint32_t value of number of free bytes in the tx circular buffer
+
+*****************************************************************************/
+DRVIFLIB_API uint32_t
+DtsTxFreeSize(
+    HANDLE  hDevice
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/lib/win32/libcrystalhd/libcrystalhd_version.h b/lib/win32/libcrystalhd/libcrystalhd_version.h
new file mode 100644
index 0000000..9ac7632
--- /dev/null
+++ b/lib/win32/libcrystalhd/libcrystalhd_version.h
@@ -0,0 +1,82 @@
+/********************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: libcrystalhd_version.h
+ *
+ *  Description: Version numbering for the driver use.
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ ********************************************************************
+ * This header is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This header is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this header.  If not, see <http://www.gnu.org/licenses/>.
+ *******************************************************************/
+
+#ifndef _BC_DTS_VERSION_LNX_
+#define _BC_DTS_VERSION_LNX_
+//
+// The version format that we are adopting is
+// MajorVersion.MinorVersion.Revision
+// This will be the same for all the components.
+//
+//
+#define STRINGIFY_VERSION(MAJ,MIN,REV) STRINGIFIED_VERSION(MAJ,MIN,REV)
+#define STRINGIFIED_VERSION(MAJ,MIN,REV) #MAJ "." #MIN "." #REV
+
+#define STRINGIFY_VERSION_W(MAJ,MIN,REV) STRINGIFIED_VERSION_W(MAJ,MIN,REV)
+#define STRINGIFIED_VERSION_W(MAJ,MIN,REV) #MAJ "." #MIN "." #REV
+
+//
+//  Product Version number is:
+//  x.y.z.a
+//
+//  x = Major release.      1 = Dozer, 2 = Dozer + Link
+//  y = Minor release.      Should increase +1 per "real" release.
+//  z = Branch release.     0 for main branch.  This is +1 per branch release.
+//  a = Build number	+1 per candidate release.  Reset to 0 every "real" release.
+//
+//
+// Enabling Check-In rules enforcement 08092007
+//
+#define INVALID_VERSION		0xFFFF
+
+/*========================== Common For All Components =================================*/
+#define BRCM_MAJOR_VERSION	3
+
+// Note: the driver doesn't currently use these defines, it has its own
+// version information (which should match) stored in bc_dts_glob_lnx.h
+#define DRIVER_MAJOR_VERSION        BRCM_MAJOR_VERSION
+#define DRIVER_MINOR_VERSION        8
+#define DRIVER_REVISION             0
+
+#define RC_FILE_VERSION             STRINGIFY_VERSION(DRIVER_MAJOR_VERSION,DRIVER_MINOR_VERSION,DRIVER_REVISION) ".0"
+
+/*======================= Device Interface Library ========================*/
+#define DIL_MAJOR_VERSION	BRCM_MAJOR_VERSION
+#define DIL_MINOR_VERSION	20
+#define DIL_REVISION		0
+
+#define DIL_RC_FILE_VERSION	STRINGIFY_VERSION(DIL_MAJOR_VERSION,DIL_MINOR_VERSION,DIL_REVISION)
+
+/*========================== deconf utility ==============================*/
+#define DECONF_MAJOR_VERSION	BRCM_MAJOR_VERSION
+#define DECONF_MINOR_VERSION	9
+#define DECONF_REVISION		18
+#define DECONF_RC_FILE_VERSION  STRINGIFY_VERSION(DIL_MAJOR_VERSION,DIL_MINOR_VERSION,DIL_REVISION)
+
+/*========================== Firmware ==============================*/
+#define FW_MAJOR_VERSION        BRCM_MAJOR_VERSION
+#define FW_MINOR_VERSION        60
+#define FW_REVISION		39
+
+#endif
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 7f652a2..32af238 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -233,12 +233,7 @@
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Utils\AEUtil.cpp" />
     <ClCompile Include="..\..\xbmc\cores\DataCacheCore.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Audio\DVDAudioCodecPassthrough.cpp" />
-    <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Overlay\contrib\cc_decoder.c">
-      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">CompileAsCpp</CompileAs>
-      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">CompileAsCpp</CompileAs>
-      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug Testsuite|Win32'">CompileAsCpp</CompileAs>
-    </ClCompile>
-    <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Overlay\contrib\cc_decoder708.cpp" />
+    <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\CrystalHD.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodec.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDDemuxers\DVDDemuxBXA.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDDemuxers\DVDDemuxCC.cpp" />
@@ -1513,6 +1508,7 @@
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\DVDCodecUtils.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\DVDFactoryCodec.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Audio\DVDAudioCodecFFmpeg.cpp" />
+    <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecCrystalHD.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecFFmpeg.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecLibMpeg2.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoPPFFmpeg.cpp" />
@@ -1692,7 +1688,11 @@
     <ClInclude Include="..\..\xbmc\Autorun.h" />
     <ClInclude Include="..\..\xbmc\AutoSwitch.h" />
     <ClInclude Include="..\..\xbmc\BackgroundInfoLoader.h" />
+<<<<<<< HEAD
     <ClInclude Include="..\..\xbmc\ContextMenuManager.h" />
+=======
+    <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\CrystalHD.h" />
+>>>>>>> parent of 2ca4c9a... Merge pull request #5105 from fritsch/removecrystalhd
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDDemuxers\DVDDemuxPVRClient.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamBluray.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamPVRManager.h" />
@@ -2188,6 +2188,7 @@
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Audio\DVDAudioCodecFFmpeg.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DllLibMpeg2.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodec.h" />
+    <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecCrystalHD.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecFFmpeg.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecLibMpeg2.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoPPFFmpeg.h" />
@@ -2545,4 +2546,4 @@
     </VisualStudio>
   </ProjectExtensions>
   <Import Project="$(SolutionDir)\$(ProjectFileName).targets.user" Condition="Exists('$(SolutionDir)\$(ProjectFileName).targets.user')" />
-</Project>
\ No newline at end of file
+</Project>
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index cd39ec6..c5c90bb 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -423,6 +423,9 @@
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Audio\DVDAudioCodecFFmpeg.cpp">
       <Filter>cores\dvdplayer\DVDCodecs\Audio</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecCrystalHD.cpp">
+      <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecFFmpeg.cpp">
       <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
     </ClCompile>
@@ -756,6 +759,9 @@
     <ClCompile Include="..\..\xbmc\addons\PluginSource.cpp">
       <Filter>addons</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\CrystalHD.cpp">
+      <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\cores\VideoRenderers\VideoShaders\WinVideoFilter.cpp">
       <Filter>cores\VideoRenderers\Shaders</Filter>
     </ClCompile>
@@ -3197,6 +3203,9 @@
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodec.h">
       <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecCrystalHD.h">
+      <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodecFFmpeg.h">
       <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
     </ClInclude>
@@ -3605,6 +3614,9 @@
     <ClInclude Include="..\..\xbmc\addons\PluginSource.h">
       <Filter>addons</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\CrystalHD.h">
+      <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\cores\VideoRenderers\VideoShaders\WinVideoFilter.h">
       <Filter>cores\VideoRenderers\Shaders</Filter>
     </ClInclude>
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 3ef33e0..a0cd0dd 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -792,6 +792,15 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.usechd" type="boolean" label="13428" help="36159">
+          <requirement>HasCrystalHDDevice</requirement>
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.decodingmethod" operator="is">1</dependency>
+          </dependencies>
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoplayer.useomx" type="boolean" label="13430" help="36161">
           <requirement>HAVE_LIBOPENMAX</requirement>
           <level>2</level>
diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index 45adf25..cd3c95d 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -27,12 +27,12 @@ endif
 
 ifeq ($(OS),ios)
   DEPENDS += Backrow
-  EXCLUDED_DEPENDS = libcec libusb
+  EXCLUDED_DEPENDS = libcec libcrystalhd libusb gmp nettle gnutls
 endif
 
 ifeq ($(OS),osx)
-  DEPENDS += libGLEW libsdl
-  EXCLUDED_DEPENDS = libusb
+  DEPENDS += libGLEW libsdl libcrystalhd
+  EXCLUDED_DEPENDS = libusb gmp nettle gnutls
 endif
 
 ifeq ($(OS),android)
diff --git a/tools/depends/target/libcrystalhd/Makefile b/tools/depends/target/libcrystalhd/Makefile
new file mode 100644
index 0000000..fa3d443
--- /dev/null
+++ b/tools/depends/target/libcrystalhd/Makefile
@@ -0,0 +1,15 @@
+include ../../Makefile.include
+DEPS= ../../Makefile.include
+
+SOURCE=libcrystalhd
+
+all: .installed-$(PLATFORM)
+
+.installed-$(PLATFORM): $(SOURCE)
+	mkdir -p $(PREFIX)/include
+	cp -rf $(SOURCE) $(PREFIX)/include/
+	touch $@
+
+clean:
+distclean::
+	rm -f .installed-$(PLATFORM)
diff --git a/tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_defs.h b/tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_defs.h
new file mode 100644
index 0000000..2bffb80
--- /dev/null
+++ b/tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_defs.h
@@ -0,0 +1,635 @@
+/********************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: bc_dts_defs.h
+ *
+ *  Description: Common definitions for all components. Only types
+ *		 is allowed to be included from this file.
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ ********************************************************************
+ * This header is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This header is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this header.  If not, see <http://www.gnu.org/licenses/>.
+ *******************************************************************/
+
+#ifndef _BC_DTS_DEFS_H_
+#define _BC_DTS_DEFS_H_
+
+#include "bc_dts_types.h"
+
+/* BIT Mask */
+#define BC_BIT(_x)		(1 << (_x))
+
+typedef enum _BC_STATUS {
+	BC_STS_SUCCESS		= 0,
+	BC_STS_INV_ARG		= 1,
+	BC_STS_BUSY		= 2,
+	BC_STS_NOT_IMPL		= 3,
+	BC_STS_PGM_QUIT		= 4,
+	BC_STS_NO_ACCESS	= 5,
+	BC_STS_INSUFF_RES	= 6,
+	BC_STS_IO_ERROR		= 7,
+	BC_STS_NO_DATA		= 8,
+	BC_STS_VER_MISMATCH	= 9,
+	BC_STS_TIMEOUT		= 10,
+	BC_STS_FW_CMD_ERR	= 11,
+	BC_STS_DEC_NOT_OPEN	= 12,
+	BC_STS_ERR_USAGE	= 13,
+	BC_STS_IO_USER_ABORT	= 14,
+	BC_STS_IO_XFR_ERROR	= 15,
+	BC_STS_DEC_NOT_STARTED	= 16,
+	BC_STS_FWHEX_NOT_FOUND	= 17,
+	BC_STS_FMT_CHANGE	= 18,
+	BC_STS_HIF_ACCESS	= 19,
+	BC_STS_CMD_CANCELLED	= 20,
+	BC_STS_FW_AUTH_FAILED	= 21,
+	BC_STS_BOOTLOADER_FAILED = 22,
+	BC_STS_CERT_VERIFY_ERROR = 23,
+	BC_STS_DEC_EXIST_OPEN	= 24,
+	BC_STS_PENDING		= 25,
+	BC_STS_CLK_NOCHG	= 26,
+
+	/* Must be the last one.*/
+	BC_STS_ERROR		= -1
+} BC_STATUS;
+
+/*------------------------------------------------------*
+ *    Registry Key Definitions				*
+ *------------------------------------------------------*/
+#define BC_REG_KEY_MAIN_PATH	"Software\\Broadcom\\MediaPC\\CrystalHD"
+#define BC_REG_KEY_FWPATH		"FirmwareFilePath"
+#define BC_REG_KEY_SEC_OPT		"DbgOptions"
+
+/*
+ * Options:
+ *
+ *  b[5] = Enable RSA KEY in EEPROM Support
+ *  b[6] = Enable Old PIB scheme. (0 = Use PIB with video scheme)
+ *
+ *  b[12] = Enable send message to NotifyIcon
+ *
+ */
+
+typedef enum _BC_SW_OPTIONS {
+	BC_OPT_DOSER_OUT_ENCRYPT	= BC_BIT(3),
+	BC_OPT_LINK_OUT_ENCRYPT		= BC_BIT(29),
+} BC_SW_OPTIONS;
+
+typedef struct _BC_REG_CONFIG{
+	uint32_t		DbgOptions;
+} BC_REG_CONFIG;
+
+#if defined(__KERNEL__) || defined(__LINUX_USER__)
+#else
+/* Align data structures */
+#define ALIGN(x)	__declspec(align(x))
+#endif
+
+/* mode
+ * b[0]..b[7]	= _DtsDeviceOpenMode
+ * b[8]		=  Load new FW
+ * b[9]		=  Load file play back FW
+ * b[10]	=  Disk format (0 for HD DVD and 1 for BLU ray)
+ * b[11]-b[15]	=  default output resolution
+ * b[16]	=  Skip TX CPB Buffer Check
+ * b[17]	=  Adaptive Output Encrypt/Scramble Scheme
+ * b[18]-b[31]	=  reserved for future use
+ */
+
+/* To allow multiple apps to open the device. */
+enum _DtsDeviceOpenMode {
+	DTS_PLAYBACK_MODE = 0,
+	DTS_DIAG_MODE,
+	DTS_MONITOR_MODE,
+	DTS_HWINIT_MODE
+};
+
+/* To enable the filter to selectively enable/disable fixes or erratas */
+enum _DtsDeviceFixMode {
+	DTS_LOAD_NEW_FW		= BC_BIT(8),
+	DTS_LOAD_FILE_PLAY_FW	= BC_BIT(9),
+	DTS_DISK_FMT_BD		= BC_BIT(10),
+	/* b[11]-b[15] : Default output resolution */
+	DTS_SKIP_TX_CHK_CPB	= BC_BIT(16),
+	DTS_ADAPTIVE_OUTPUT_PER	= BC_BIT(17),
+	DTS_INTELLIMAP		= BC_BIT(18),
+	/* b[19]-b[21] : select clock frequency */
+	DTS_PLAYBACK_DROP_RPT_MODE = BC_BIT(22),
+	DTS_DIAG_TEST_MODE = BC_BIT(23),
+	DTS_SINGLE_THREADED_MODE = BC_BIT(24),
+	DTS_FILTER_MODE = BC_BIT(25),
+	DTS_MFT_MODE = BC_BIT(26)
+};
+
+#define DTS_DFLT_RESOLUTION(x)	(x<<11)
+
+#define DTS_DFLT_CLOCK(x) (x<<19)
+
+/* F/W File Version corresponding to S/W Releases */
+enum _FW_FILE_VER {
+	/* S/W release: 02.04.02	F/W release 2.12.2.0 */
+	BC_FW_VER_020402 = ((12<<16) | (2<<8) | (0))
+};
+
+/*------------------------------------------------------*
+ *    Stream Types for DtsOpenDecoder()			*
+ *------------------------------------------------------*/
+enum _DtsOpenDecStreamTypes {
+	BC_STREAM_TYPE_ES		= 0,
+	BC_STREAM_TYPE_PES		= 1,
+	BC_STREAM_TYPE_TS		= 2,
+	BC_STREAM_TYPE_ES_TSTAMP	= 6,
+};
+
+/*------------------------------------------------------*
+ *    Video Algorithms for DtsSetVideoParams()		*
+ *------------------------------------------------------*/
+enum _DtsSetVideoParamsAlgo {
+	BC_VID_ALGO_H264		= 0,
+	BC_VID_ALGO_MPEG2		= 1,
+	BC_VID_ALGO_VC1			= 4,
+	BC_VID_ALGO_DIVX		= 6,
+	BC_VID_ALGO_VC1MP		= 7,
+};
+
+/*------------------------------------------------------*
+ *    MPEG Extension to the PPB				*
+ *------------------------------------------------------*/
+#define BC_MPEG_VALID_PANSCAN		(1)
+
+typedef struct _BC_PIB_EXT_MPEG {
+	uint32_t	valid;
+	/* Always valid,  defaults to picture size if no
+	 * sequence display extension in the stream. */
+	uint32_t	display_horizontal_size;
+	uint32_t	display_vertical_size;
+
+	/* MPEG_VALID_PANSCAN
+	 * Offsets are a copy values from the MPEG stream. */
+	uint32_t	offset_count;
+	int32_t		horizontal_offset[3];
+	int32_t		vertical_offset[3];
+
+} BC_PIB_EXT_MPEG;
+
+/*------------------------------------------------------*
+ *    H.264 Extension to the PPB			*
+ *------------------------------------------------------*/
+/* Bit definitions for 'other.h264.valid' field */
+#define H264_VALID_PANSCAN		(1)
+#define H264_VALID_SPS_CROP		(2)
+#define H264_VALID_VUI			(4)
+
+typedef struct _BC_PIB_EXT_H264 {
+	/* 'valid' specifies which fields (or sets of
+	 * fields) below are valid.  If the corresponding
+	 * bit in 'valid' is NOT set then that field(s)
+	 * is (are) not initialized. */
+	uint32_t	valid;
+
+	/* H264_VALID_PANSCAN */
+	uint32_t	pan_scan_count;
+	int32_t		pan_scan_left[3];
+	int32_t		pan_scan_right[3];
+	int32_t		pan_scan_top[3];
+	int32_t		pan_scan_bottom[3];
+
+	/* H264_VALID_SPS_CROP */
+	int32_t		sps_crop_left;
+	int32_t		sps_crop_right;
+	int32_t		sps_crop_top;
+	int32_t		sps_crop_bottom;
+
+	/* H264_VALID_VUI */
+	uint32_t	chroma_top;
+	uint32_t	chroma_bottom;
+
+} BC_PIB_EXT_H264;
+
+/*------------------------------------------------------*
+ *    VC1 Extension to the PPB				*
+ *------------------------------------------------------*/
+#define VC1_VALID_PANSCAN		(1)
+
+typedef struct _BC_PIB_EXT_VC1 {
+	uint32_t	valid;
+
+	/* Always valid, defaults to picture size if no
+	 * sequence display extension in the stream. */
+	uint32_t	display_horizontal_size;
+	uint32_t	display_vertical_size;
+
+	/* VC1 pan scan windows */
+	uint32_t	num_panscan_windows;
+	int32_t		ps_horiz_offset[4];
+	int32_t		ps_vert_offset[4];
+	int32_t		ps_width[4];
+	int32_t		ps_height[4];
+
+} BC_PIB_EXT_VC1;
+
+
+/*------------------------------------------------------*
+ *    Picture Information Block				*
+ *------------------------------------------------------*/
+#if defined(__LINUX_USER__)
+/* Values for 'pulldown' field.  '0' means no pulldown information
+ * was present for this picture. */
+enum {
+	vdecNoPulldownInfo	= 0,
+	vdecTop			= 1,
+	vdecBottom		= 2,
+	vdecTopBottom		= 3,
+	vdecBottomTop		= 4,
+	vdecTopBottomTop	= 5,
+	vdecBottomTopBottom	= 6,
+	vdecFrame_X2		= 7,
+	vdecFrame_X3		= 8,
+	vdecFrame_X1		= 9,
+	vdecFrame_X4		= 10,
+};
+
+/* Values for the 'frame_rate' field. */
+enum {
+	vdecFrameRateUnknown = 0,
+	vdecFrameRate23_97,
+	vdecFrameRate24,
+	vdecFrameRate25,
+	vdecFrameRate29_97,
+	vdecFrameRate30,
+	vdecFrameRate50,
+	vdecFrameRate59_94,
+	vdecFrameRate60,
+	vdecFrameRate14_985,
+	vdecFrameRate7_496,
+};
+
+/* Values for the 'aspect_ratio' field. */
+enum {
+	vdecAspectRatioUnknown = 0,
+	vdecAspectRatioSquare,
+	vdecAspectRatio12_11,
+	vdecAspectRatio10_11,
+	vdecAspectRatio16_11,
+	vdecAspectRatio40_33,
+	vdecAspectRatio24_11,
+	vdecAspectRatio20_11,
+	vdecAspectRatio32_11,
+	vdecAspectRatio80_33,
+	vdecAspectRatio18_11,
+	vdecAspectRatio15_11,
+	vdecAspectRatio64_33,
+	vdecAspectRatio160_99,
+	vdecAspectRatio4_3,
+	vdecAspectRatio16_9,
+	vdecAspectRatio221_1,
+	vdecAspectRatioOther = 255,
+};
+
+/* Values for the 'colour_primaries' field. */
+enum {
+	vdecColourPrimariesUnknown = 0,
+	vdecColourPrimariesBT709,
+	vdecColourPrimariesUnspecified,
+	vdecColourPrimariesReserved,
+	vdecColourPrimariesBT470_2M = 4,
+	vdecColourPrimariesBT470_2BG,
+	vdecColourPrimariesSMPTE170M,
+	vdecColourPrimariesSMPTE240M,
+	vdecColourPrimariesGenericFilm,
+};
+
+enum {
+	vdecRESOLUTION_CUSTOM	= 0x00000000, /* custom */
+	vdecRESOLUTION_480i	= 0x00000001, /* 480i */
+	vdecRESOLUTION_1080i	= 0x00000002, /* 1080i (1920x1080, 60i) */
+	vdecRESOLUTION_NTSC	= 0x00000003, /* NTSC (720x483, 60i) */
+	vdecRESOLUTION_480p	= 0x00000004, /* 480p (720x480, 60p) */
+	vdecRESOLUTION_720p	= 0x00000005, /* 720p (1280x720, 60p) */
+	vdecRESOLUTION_PAL1	= 0x00000006, /* PAL_1 (720x576, 50i) */
+	vdecRESOLUTION_1080i25	= 0x00000007, /* 1080i25 (1920x1080, 50i) */
+	vdecRESOLUTION_720p50	= 0x00000008, /* 720p50 (1280x720, 50p) */
+	vdecRESOLUTION_576p	= 0x00000009, /* 576p (720x576, 50p) */
+	vdecRESOLUTION_1080i29_97 = 0x0000000A, /* 1080i (1920x1080, 59.94i) */
+	vdecRESOLUTION_720p59_94  = 0x0000000B, /* 720p (1280x720, 59.94p) */
+	vdecRESOLUTION_SD_DVD	= 0x0000000C, /* SD DVD (720x483, 60i) */
+	vdecRESOLUTION_480p656	= 0x0000000D, /* 480p (720x480, 60p), output bus width 8 bit, clock 74.25MHz */
+	vdecRESOLUTION_1080p23_976 = 0x0000000E, /* 1080p23_976 (1920x1080, 23.976p) */
+	vdecRESOLUTION_720p23_976  = 0x0000000F, /* 720p23_976 (1280x720p, 23.976p) */
+	vdecRESOLUTION_240p29_97   = 0x00000010, /* 240p (1440x240, 29.97p ) */
+	vdecRESOLUTION_240p30	= 0x00000011, /* 240p (1440x240, 30p) */
+	vdecRESOLUTION_288p25	= 0x00000012, /* 288p (1440x288p, 25p) */
+	vdecRESOLUTION_1080p29_97 = 0x00000013, /* 1080p29_97 (1920x1080, 29.97p) */
+	vdecRESOLUTION_1080p30	= 0x00000014, /* 1080p30 (1920x1080, 30p) */
+	vdecRESOLUTION_1080p24	= 0x00000015, /* 1080p24 (1920x1080, 24p) */
+	vdecRESOLUTION_1080p25	= 0x00000016, /* 1080p25 (1920x1080, 25p) */
+	vdecRESOLUTION_720p24	= 0x00000017, /* 720p24 (1280x720, 25p) */
+	vdecRESOLUTION_720p29_97  = 0x00000018, /* 720p29.97 (1280x720, 29.97p) */
+	vdecRESOLUTION_480p23_976 = 0x00000019, /* 480p23.976 (720*480, 23.976) */
+	vdecRESOLUTION_480p29_97  = 0x0000001A, /* 480p29.976 (720*480, 29.97p) */
+	vdecRESOLUTION_576p25	= 0x0000001B, /* 576p25 (720*576, 25p) */
+	/* For Zero Frame Rate */
+	vdecRESOLUTION_480p0	= 0x0000001C, /* 480p (720x480, 0p) */
+	vdecRESOLUTION_480i0	= 0x0000001D, /* 480i (720x480, 0i) */
+	vdecRESOLUTION_576p0	= 0x0000001E, /* 576p (720x576, 0p) */
+	vdecRESOLUTION_720p0	= 0x0000001F, /* 720p (1280x720, 0p) */
+	vdecRESOLUTION_1080p0	= 0x00000020, /* 1080p (1920x1080, 0p) */
+	vdecRESOLUTION_1080i0	= 0x00000021, /* 1080i (1920x1080, 0i) */
+};
+
+/* Bit definitions for 'flags' field */
+#define VDEC_FLAG_EOS				(0x0004)
+
+#define VDEC_FLAG_FRAME				(0x0000)
+#define VDEC_FLAG_FIELDPAIR			(0x0008)
+#define VDEC_FLAG_TOPFIELD			(0x0010)
+#define VDEC_FLAG_BOTTOMFIELD			(0x0018)
+
+#define VDEC_FLAG_PROGRESSIVE_SRC		(0x0000)
+#define VDEC_FLAG_INTERLACED_SRC		(0x0020)
+#define VDEC_FLAG_UNKNOWN_SRC			(0x0040)
+
+#define VDEC_FLAG_BOTTOM_FIRST			(0x0080)
+#define VDEC_FLAG_LAST_PICTURE			(0x0100)
+
+#define VDEC_FLAG_PICTURE_META_DATA_PRESENT	(0x40000)
+
+#endif /* __LINUX_USER__ */
+
+typedef struct _BC_PIC_INFO_BLOCK {
+	/* Common fields. */
+	uint64_t	timeStamp;	/* Timestamp */
+	uint32_t	picture_number;	/* Ordinal display number  */
+	uint32_t	width;		/* pixels	    */
+	uint32_t	height;		/* pixels	    */
+	uint32_t	chroma_format;	/* 0x420, 0x422 or 0x444 */
+	uint32_t	pulldown;
+	uint32_t	flags;
+	uint32_t	frame_rate;
+	uint32_t	aspect_ratio;
+	uint32_t	colour_primaries;
+	uint32_t	picture_meta_payload;
+	uint32_t	sess_num;
+	uint32_t	ycom;
+	uint32_t	custom_aspect_ratio_width_height;
+	uint32_t	n_drop;	/* number of non-reference frames remaining to be dropped */
+
+	/* Protocol-specific extensions. */
+	union {
+		BC_PIB_EXT_H264	h264;
+		BC_PIB_EXT_MPEG	mpeg;
+		BC_PIB_EXT_VC1	 vc1;
+	} other;
+
+} BC_PIC_INFO_BLOCK, *PBC_PIC_INFO_BLOCK;
+
+/*------------------------------------------------------*
+ *    ProcOut Info					*
+ *------------------------------------------------------*/
+/* Optional flags for ProcOut Interface.*/
+enum _POUT_OPTIONAL_IN_FLAGS_{
+	/* Flags from App to Device */
+	BC_POUT_FLAGS_YV12	  = 0x01,	/* Copy Data in YV12 format */
+	BC_POUT_FLAGS_STRIDE	  = 0x02,	/* Stride size is valid. */
+	BC_POUT_FLAGS_SIZE	  = 0x04,	/* Take size information from Application */
+	BC_POUT_FLAGS_INTERLACED  = 0x08,	/* copy only half the bytes */
+	BC_POUT_FLAGS_INTERLEAVED = 0x10,	/* interleaved frame */
+	BC_POUT_FLAGS_STRIDE_UV	  = 0x20,	/* Stride size is valid (for UV buffers). */
+	BC_POUT_FLAGS_MODE	  = 0x40,	/* Take output mode from Application, overrides YV12 flag if on */
+
+	/* Flags from Device to APP */
+	BC_POUT_FLAGS_FMT_CHANGE  = 0x10000,	/* Data is not VALID when this flag is set */
+	BC_POUT_FLAGS_PIB_VALID	  = 0x20000,	/* PIB Information valid */
+	BC_POUT_FLAGS_ENCRYPTED	  = 0x40000,	/* Data is encrypted. */
+	BC_POUT_FLAGS_FLD_BOT	  = 0x80000,	/* Bottom Field data */
+};
+
+//Decoder Capability
+enum DECODER_CAP_FLAGS
+{
+	BC_DEC_FLAGS_H264		= 0x01,
+	BC_DEC_FLAGS_MPEG2		= 0x02,
+	BC_DEC_FLAGS_VC1		= 0x04,
+	BC_DEC_FLAGS_M4P2		= 0x08,	//MPEG-4 Part 2: Divx, Xvid etc.
+};
+
+#if defined(__KERNEL__) || defined(__LINUX_USER__)
+typedef BC_STATUS(*dts_pout_callback)(void  *shnd, uint32_t width, uint32_t height, uint32_t stride, void *pOut);
+#else
+typedef BC_STATUS(*dts_pout_callback)(void  *shnd, uint32_t width, uint32_t height, uint32_t stride, struct _BC_DTS_PROC_OUT *pOut);
+#endif
+
+/* Line 21 Closed Caption */
+/* User Data */
+#define MAX_UD_SIZE		1792	/* 1920 - 128 */
+
+typedef struct _BC_DTS_PROC_OUT {
+	uint8_t		*Ybuff;			/* Caller Supplied buffer for Y data */
+	uint32_t	YbuffSz;		/* Caller Supplied Y buffer size */
+	uint32_t	YBuffDoneSz;		/* Transferred Y datasize */
+
+	uint8_t		*UVbuff;		/* Caller Supplied buffer for UV data */
+	uint32_t	UVbuffSz;		/* Caller Supplied UV buffer size */
+	uint32_t	UVBuffDoneSz;		/* Transferred UV data size */
+
+	uint32_t	StrideSz;		/* Caller supplied Stride Size */
+	uint32_t	PoutFlags;		/* Call IN Flags */
+
+	uint32_t	discCnt;		/* Picture discontinuity count */
+
+	BC_PIC_INFO_BLOCK PicInfo;		/* Picture Information Block Data */
+
+	/* Line 21 Closed Caption */
+	/* User Data */
+	uint32_t	UserDataSz;
+	uint8_t		UserData[MAX_UD_SIZE];
+
+	void		*hnd;
+	dts_pout_callback AppCallBack;
+	uint8_t		DropFrames;
+	uint8_t		b422Mode;		/* Picture output Mode */
+	uint8_t		bPibEnc;		/* PIB encrypted */
+	uint8_t		bRevertScramble;
+	uint32_t	StrideSzUV;		/* Caller supplied Stride Size */
+
+} BC_DTS_PROC_OUT;
+
+typedef struct _BC_DTS_STATUS {
+	uint8_t		ReadyListCount;	/* Number of frames in ready list (reported by driver) */
+	uint8_t		FreeListCount;	/* Number of frame buffers free.  (reported by driver) */
+	uint8_t		PowerStateChange; /* Number of active state power transitions (reported by driver) */
+	uint8_t		reserved_[1];
+
+	uint32_t	FramesDropped;	/* Number of frames dropped.  (reported by DIL) */
+	uint32_t	FramesCaptured;	/* Number of frames captured. (reported by DIL) */
+	uint32_t	FramesRepeated;	/* Number of frames repeated. (reported by DIL) */
+
+	uint32_t	InputCount;	/* Times compressed video has been sent to the HW.
+					 * i.e. Successful DtsProcInput() calls (reported by DIL) */
+	uint64_t	InputTotalSize;	/* Amount of compressed video that has been sent to the HW.
+					 * (reported by DIL) */
+	uint32_t	InputBusyCount;	/* Times compressed video has attempted to be sent to the HW
+					 * but the input FIFO was full. (reported by DIL) */
+
+	uint32_t	PIBMissCount;	/* Amount of times a PIB is invalid. (reported by DIL) */
+
+	uint32_t	cpbEmptySize;	/* supported only for H.264, specifically changed for
+					 * SingleThreadedAppMode. Report size of CPB buffer available.
+					 * Reported by DIL */
+	uint64_t	NextTimeStamp;	/* TimeStamp of the next picture that will be returned
+					 * by a call to ProcOutput. Added for SingleThreadedAppMode.
+					 * Reported back from the driver */
+	uint8_t		TxBufData;
+
+	uint8_t		reserved__[3];
+
+	uint32_t	picNumFlags; /* Picture number and flags of the next picture to be delivered from the driver */
+
+	uint8_t		reserved___[8];
+
+} BC_DTS_STATUS;
+
+#define BC_SWAP32(_v)			\
+	((((_v) & 0xFF000000)>>24)|	\
+	  (((_v) & 0x00FF0000)>>8)|	\
+	  (((_v) & 0x0000FF00)<<8)|	\
+	  (((_v) & 0x000000FF)<<24))
+
+#define WM_AGENT_TRAYICON_DECODER_OPEN	10001
+#define WM_AGENT_TRAYICON_DECODER_CLOSE	10002
+#define WM_AGENT_TRAYICON_DECODER_START	10003
+#define WM_AGENT_TRAYICON_DECODER_STOP	10004
+#define WM_AGENT_TRAYICON_DECODER_RUN	10005
+#define WM_AGENT_TRAYICON_DECODER_PAUSE	10006
+
+#define MAX_COLOR_SPACES	3
+
+typedef enum _BC_OUTPUT_FORMAT {
+	MODE420			= 0x0,
+	MODE422_YUY2		= 0x1,
+	MODE422_UYVY		= 0x2,
+	OUTPUT_MODE420		= 0x0,
+	OUTPUT_MODE422_YUY2	= 0x1,
+	OUTPUT_MODE422_UYVY	= 0x2,
+	OUTPUT_MODE420_NV12	= 0x0,
+	OUTPUT_MODE_INVALID	= 0xFF,
+} BC_OUTPUT_FORMAT;
+
+typedef struct _BC_COLOR_SPACES_ {
+	BC_OUTPUT_FORMAT	OutFmt[MAX_COLOR_SPACES];
+	uint16_t		Count;
+} BC_COLOR_SPACES;
+
+
+typedef enum _BC_CAPS_FLAGS_ {
+	PES_CONV_SUPPORT	= 1,	/*Support PES Conversion*/
+	MULTIPLE_DECODE_SUPPORT	= 2	/*Support multiple stream decode*/
+} BC_CAPS_FLAGS;
+
+typedef struct _BC_HW_CAPABILITY_ {
+	BC_CAPS_FLAGS		flags;
+	BC_COLOR_SPACES		ColorCaps;
+	void*			Reserved1;	/* Expansion Of API */
+
+	//Decoder Capability
+	uint32_t		DecCaps;	//DECODER_CAP_FLAGS
+} BC_HW_CAPS, *PBC_HW_CAPS;
+
+typedef struct _BC_SCALING_PARAMS_ {
+	uint32_t	sWidth;
+	uint32_t	sHeight;
+	uint32_t	DNR;
+	uint32_t	Reserved1;	/*Expansion Of API*/
+	uint8_t		*Reserved2;	/*Expansion OF API*/
+	uint32_t	Reserved3;	/*Expansion Of API*/
+	uint8_t		*Reserved4;	/*Expansion Of API*/
+
+} BC_SCALING_PARAMS, *PBC_SCALING_PARAMS;
+
+typedef enum _BC_MEDIA_SUBTYPE_ {
+	BC_MSUBTYPE_INVALID = 0,
+	BC_MSUBTYPE_MPEG1VIDEO,
+	BC_MSUBTYPE_MPEG2VIDEO,
+	BC_MSUBTYPE_H264,
+	BC_MSUBTYPE_WVC1,
+	BC_MSUBTYPE_WMV3,
+	BC_MSUBTYPE_AVC1,
+	BC_MSUBTYPE_WMVA,
+	BC_MSUBTYPE_VC1,
+	BC_MSUBTYPE_DIVX,
+	BC_MSUBTYPE_DIVX311,
+	BC_MSUBTYPE_OTHERS	/*Types to facilitate PES conversion*/
+} BC_MEDIA_SUBTYPE;
+
+typedef struct _BC_INPUT_FORMAT_ {
+	BOOL        FGTEnable;      /*Enable processing of FGT SEI*/
+	BOOL        MetaDataEnable; /*Enable retrieval of picture metadata to be sent to video pipeline.*/
+	BOOL        Progressive;    /*Instruct decoder to always try to send back progressive
+				     frames. If input content is 1080p, the decoder will
+				     ignore pull-down flags and always give 1080p output.
+				     If 1080i content is processed, the decoder will return
+				     1080i data. When this flag is not set, the decoder will
+				     use pull-down information in the input stream to decide
+				     the decoded data format.*/
+	uint32_t    OptFlags;       /*In this field bits 0:3 are used pass default frame rate, bits 4:5 are for operation mode
+				     (used to indicate Blu-ray mode to the decoder) and bit 6 is for the flag mpcOutPutMaxFRate
+				     which when set tells the FW to output at the max rate for the resolution and ignore the
+				     frame rate determined from the stream. Bit 7 is set to indicate that this is single threaded
+				     mode and the driver will be peeked to get timestamps ahead of time*/
+	BC_MEDIA_SUBTYPE mSubtype;  /* Video Media Type*/
+	uint32_t    width;
+	uint32_t    height;
+	uint32_t    startCodeSz;    /*Start code size for H264 clips*/
+	uint8_t     *pMetaData;     /*Metadata buffer that is used to pass sequence header*/
+	uint32_t    metaDataSz;     /*Metadata size*/
+	uint8_t     bEnableScaling;
+	BC_SCALING_PARAMS ScalingParams;
+} BC_INPUT_FORMAT;
+
+typedef struct _BC_INFO_CRYSTAL_ {
+	uint8_t device;
+	union {
+		struct {
+			uint32_t dilRelease:8;
+			uint32_t dilMajor:8;
+			uint32_t dilMinor:16;
+		};
+		uint32_t version;
+	} dilVersion;
+
+	union {
+		struct {
+			uint32_t drvRelease:4;
+			uint32_t drvMajor:8;
+			uint32_t drvMinor:12;
+			uint32_t drvBuild:8;
+		};
+		uint32_t version;
+	} drvVersion;
+
+	union {
+		struct {
+			uint32_t fwRelease:4;
+			uint32_t fwMajor:8;
+			uint32_t fwMinor:12;
+			uint32_t fwBuild:8;
+		};
+		uint32_t version;
+	} fwVersion;
+
+	uint32_t Reserved1; // For future expansion
+	uint32_t Reserved2; // For future expansion
+} BC_INFO_CRYSTAL, *PBC_INFO_CRYSTAL;
+
+#endif	/* _BC_DTS_DEFS_H_ */
diff --git a/tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_types.h b/tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_types.h
new file mode 100644
index 0000000..a0b9ca5
--- /dev/null
+++ b/tools/depends/target/libcrystalhd/libcrystalhd/bc_dts_types.h
@@ -0,0 +1,68 @@
+/********************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: bc_dts_types.h
+ *
+ *  Description: Data types
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ ********************************************************************
+ * This header is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This header is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this header.  If not, see <http://www.gnu.org/licenses/>.
+ *******************************************************************/
+
+#ifndef _BC_DTS_TYPES_H_
+#define _BC_DTS_TYPES_H_
+
+#ifdef __LINUX_USER__  /* Don't include these for KERNEL.. */
+#include <stdint.h>
+#endif
+
+#ifndef PVOID
+typedef void	*PVOID;
+#endif
+
+#ifndef BOOL
+typedef int	BOOL;
+#endif
+
+#ifdef __LINUX_USER__	/* Don't include these for KERNEL */
+typedef uint32_t	ULONG;
+typedef int32_t		LONG;
+typedef void		*HANDLE;
+#ifndef VOID
+typedef void		VOID;
+#endif
+typedef void		*LPVOID;
+typedef uint32_t	DWORD;
+typedef uint32_t	UINT32;
+typedef uint32_t	*LPDWORD;
+typedef unsigned char	*PUCHAR;
+
+#ifndef TRUE
+	#define TRUE		1
+#endif
+
+#ifndef FALSE
+	#define FALSE		0
+#endif
+
+#else /* !__LINUX_USER__ */
+
+/* For Kernel usage.. */
+typedef bool	bc_bool_t;
+#endif /* __LINUX_USER__ */
+
+#endif
+
diff --git a/tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_if.h b/tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_if.h
new file mode 100644
index 0000000..45fa7a6
--- /dev/null
+++ b/tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_if.h
@@ -0,0 +1,1515 @@
+/*****************************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: libcrystalhd_if.h
+ *
+ *  Description: Device Interface Library API.
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ *****************************************************************************
+ *
+ * This file is part of libcrystalhd.
+ *
+ * This library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ ****************************************************************************/
+
+#ifndef _BCM_LDIL_IF_H_
+#define _BCM_LDIL_IF_H_
+
+#include "bc_dts_defs.h"
+
+#define FLEA_MAX_TRICK_MODE_SPEED	6
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+******************************************************************************
+
+                            Theory of operation
+
+
+    The Device Interface Library (DIL) allows application level code, such
+as a DirectShow filter, to access the Broadcom CrystalHD decoder driver to 
+provide hardware decoding for MPEG-2, H.264 (AVC) and VC-1 streams.
+
+    In the Microsoft DirectShow system, the overall system graph would look 
+like the following:
+
++--------+  +---------------+  +---------------+  +--------------------+
+| Source |->| Demultiplexer |->| Audio decoder |->| DirectSound Device |
++--------+  +---------------+  +---------------+  +--------------------+
+                    |
+                    |  +-------------------------+  +----------------+
+                    +->| Broadcom decoder filter |->| Video Renderer |
+                       +-------------------------+  +----------------+
+                                  |    |  
+                            +----------------+
+                            |  Broadcom DIL  |
+                            +----------------+
+                                  |    |
+                            +-----------------+
+                            | Broadcom Driver |
+                            +-----------------+
+
+    From the view of the caller, the DIL will accept compressed video streams
+and will output decoded video frames or fields to seperate Y and UV buffers.
+The DIL is responsible solely for decoding video and has no responsibilities
+for audio nor for rendering, as shown in the above diagram.  Audio/video
+sychronization is assisted by feeding the DIL with timestamps so that it
+may pass those timestamps along with the decoded video.  The timestamped
+output video will then be presented at the appropriate time by the renderer.
+
+A minimal implementation would be:
+
+    HANDLE              hBRCMhandle;
+    uint8_t             input_buffer[INPUT_SIZE];
+    uint8_t             y_output_buffer[WIDTH*HEIGHT];
+    uint8_t             uv_output_buffer[WIDTH*HEIGHT];
+    BC_DTS_PROC_OUT     sProcOutData = { fill in your values here };
+    BC_PIC_INFO_BLOCK   sPIB = { fill in your values here };
+
+    // Acquire handle for device.
+    DtsDeviceOpen(&hBRCMhandle, 0);
+     
+    // Elemental stream.
+    DtsOpenDecoder(hBRCMhandle, 0);
+    
+    // H.264, Enable FGT SEI, do not parse metadata, no forced progressive out
+    DtsSetVideoParams(hBRCMhandle,0,1,0,0,0);
+
+    // Tell decoder to wait for input from host. (PC)
+    DtsStartDecoder(hBRCMhandle);       
+
+    // Input buffer address, input buffer size, no timestamp, Unencrypted
+    DtsProcInput(hBRCMhandle,input_buffer,sizeof(input_buffer),0,0);
+
+    // Tell PC to wait for data from decoder.
+    DtsStartCapture(hBRCMhandle);       
+
+    // 16ms timeout, pass pointer to PIB then get the decoded picture.
+    DtsProcOutput(hBRCMhandle,16,&sPIB);
+
+    // Stop the decoder.
+    DtsStopDecoder(hBRCMhandle);
+
+    // Close the decoder
+    DtsCloseDecoder(hBRCMhandle);
+
+    // Release handle for device.
+    DtsDeviceClose(hBRCMhandle);
+
+******************************************************************************
+*****************************************************************************/
+
+#define DRVIFLIB_API
+
+/*****************************************************************************
+Function name:
+
+    DtsDeviceOpen
+
+Description:
+
+    Opens a handle to the decoder device that will be used to address that
+    unique instance of the decoder for all subsequent operations.
+
+    Must be called once when the application opens the decoder for use.
+
+Parameters:
+
+    *hDevice    Pointer to device handle that will be filled in after the
+                device is successfully opened. [OUTPUT]
+
+    mode        Controls the mode in which the device is opened.
+                Currently only mode 0 (normal playback) is supported.
+                All other values will return BC_STS_INV_ARG.
+
+Return:
+
+    Returns BC_STS_SUCCESS or error codes as appropriate.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsDeviceOpen(
+    HANDLE   *hDevice,
+    uint32_t mode
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsDeviceClose
+
+Description:
+
+    Close the handle to the decoder device.
+
+    Must be called once when the application closes the decoder after use.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+
+Return:
+
+    Returns BC_STS_SUCCESS or error codes as appropriate.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsDeviceClose(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetVersion
+
+Description:
+
+    Get version information from the driver as well as API library.
+    Version numbers are maintained in <Major>.<Minor>.<Revision> format.
+    Example ?01.23.4567
+
+    The device must have been previously opened for this call to succeed.
+    The individual components of the revision number are available as follows:
+
+    o Major     (8 Bits) : Bit 31 ?24
+    o Minor     (8 Bits) : Bit 23 ?16
+    o Revision (16 Bits) : Bits 15 ?Bit 0.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+    DrVer       Device driver version
+    DilVer      Driver interface library version
+
+Return:
+    The revision numbers from the currently loaded driver as well as the
+    driver interface API library.
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetVersion(
+    HANDLE   hDevice,
+    uint32_t *DrVer,
+    uint32_t *DilVer
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetFWVersionFromFile
+
+Description:
+
+    Get version information from the Firmware Bin file when FW is not running
+    Version numbers in FW are maintained in <Major>.<Minor>.<Spl Revision> format.
+    the return value will be of the format:
+    (Major << 16) | (Minor<<8) | Spl_rev ?012345
+
+    The individual components of the revision number are available as follows:
+
+    o Major     (8 Bits) : Bit 24 ?16
+    o Minor     (8 Bits) : Bit 16 ?8
+    o Revision (16 Bits) : Bits 8 ?0.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+    StreamVer   Stream FW version
+    DecVer      VDEC FW version
+    Rsvd        Reserved for future use
+
+Return:
+    The Stream FW Version umbers from the FW bin file in the install directory
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetFWVersionFromFile(
+    HANDLE   hDevice,
+    uint32_t *StreamVer,
+    uint32_t *DecVer,
+    char     *fname
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetFWVersion
+
+Description:
+
+    Get version information from the Firmware. The version information is obtained
+    from Bin file when the flag is not set. When the flag is set, a FW command is
+    issued to get the version numbers.
+    Version numbers in FW are maintained in <Major>.<Minor>.<Spl Revision> format.
+    Version number will be returned in the following format
+    (Major << 16) | (Minor<<8) | Spl_rev ?012345
+
+    The individual components of the revision number are available as follows:
+
+    o Major     (8 Bits) : Bit 24 ?16
+    o Minor     (8 Bits) : Bit 16 ?8
+    o Revision (16 Bits) : Bits 8 ?Bit 0.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen
+    StreamVer   Stream FW version
+    DecVer      VDEC FW version
+    HwVer       Hardware version
+    Rsvd        Reserved for future use
+    flag        Reseved for future use
+
+Return:
+    The Stream FW Version number, VDEC FW version and Hwrev
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetFWVersion(
+    HANDLE   hDevice,
+    uint32_t *StreamVer,
+    uint32_t *DecVer,
+    uint32_t *HwVer,
+    char     *fname,
+    uint32_t flag
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsOpenDecoder
+
+Description:
+
+    Open the decoder for playback operations and sets appropriate parameters
+    for decode of input video data.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    StreamType  Currently supported streams are:
+                        Elementary Streams with no timestamp management (0)
+                        Transport Streams (2)
+                        Elementary Streams with timestamp management (6)
+                All other values will return BC_STS_INV_ARG.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsOpenDecoder(
+    HANDLE   hDevice,
+    uint32_t StreamType
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsCloseDecoder
+
+Description:
+
+    Close the decoder. No further pictures will be produced and all input
+    will be ignored.
+
+    The device must have been previously opened for this call to succeed.
+    This function closes the decoder and cleans up the state of the driver
+    and the library. All pending pictures will be dropped and all outstanding
+    transfers to and from the decoder will be aborted.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsCloseDecoder(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsStartDecoder
+
+Description:
+
+    Start the actual processing of input data. Before this command the
+    decoder will ignore all of the presented input data.
+
+    DtsOpenDecoder must always be followed by a DtsStartDecoder for the
+    decoder to start processing input data. The device must have been
+    previously opened for this call to succeed. In addition the video
+    parameters for codec must have been set via a call to DtsSetVideoParams.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStartDecoder(
+    HANDLE hDevice
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetVideoParams
+
+Description:
+
+    Sets various codec parameters that would be used by a subsequent call
+    to DtsStartDecoder.
+
+    DtsSetVideoParams must always be called before DtsStartDecoder for the
+    decoder to start processing input data. The device must have been
+    previously opened for this call to succeed.
+
+Parameters:
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    videoAlg        Video Codec to be enabled to decode stream.
+                    H.264 (0), VC-1 (4) and MPEG-2 (1) currently supported.
+                    All other values will return BC_STS_INV_ARG
+    FGTEnable       Enable processing of FGT SEI.
+    MetaDataEnable  Enable retrieval of picture metadata to be sent to video
+                    pipeline.
+    Progressive     Instruct decoder to always try to send back progressive
+                    frames. If input content is 1080p, the decoder will
+                    ignore pull-down flags and always give 1080p output.
+                    If 1080i content is processed, the decoder will return
+                    1080i data. When this flag is not set, the decoder will
+                    use pull-down information in the input stream to decide
+                    the decoded data format.
+    OptFlags        In this field bits 0:3 are used pass default frame rate,
+                    bits 4:5 are for operation mode (used to indicate Blu-ray
+                    mode to the decoder) and bit 6 is for the flag mpcOutPutMaxFRate
+                    which when set tells the FW to output at the max rate for the
+                    resolution and ignore the frame rate determined from the
+                    stream. Bit 7 is set to indicate that this is single threaded mode
+                    and the driver will be peeked to get timestamps ahead of time.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetVideoParams(
+    HANDLE   hDevice,
+    uint32_t videoAlg,
+    BOOL     FGTEnable,
+    BOOL     MetaDataEnable,
+    BOOL     Progressive,
+    uint32_t OptFlags
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetInputFormat
+    
+Description:
+
+    Sets input video's various parameters that would be used by a subsequent call
+    to DtsStartDecoder.
+
+    DtsSetInputFormat must always be called before DtsStartDecoder for the
+    decoder to start processing input data. The device must have been
+    previously opened for this call to succeed.
+
+Parameters:
+    hDevice         Handle to device. This is obtained via a prior call to DtsDeviceOpen.
+    pInputFormat Pointer to the BC_INPUT_FORMAT data.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetInputFormat(
+    HANDLE  			hDevice,
+    BC_INPUT_FORMAT   *pInputFormat
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetVideoParams
+
+Description:
+
+    Returns various codec parameters that would be used by a subsequent call
+    to DtsStartDecoder. These parameters are either default values or were
+    set via a prior call to DtsSetVideoParams
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    *videoAlg       See DtsSetVideoParams. [OUTPUT]
+    *FGTEnable      See DtsSetVideoParams. [OUTPUT]
+    *MetaDataEnable See DtsSetVideoParams. [OUTPUT]
+    *Progressive    See DtsSetVideoParams. [OUTPUT]
+    Reserved        This field is reserved for possible future expansion.
+                    Set to 0.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetVideoParams(
+    HANDLE   hDevice,
+    uint32_t *videoAlg,
+    BOOL     *FGTEnable,
+    BOOL     *MetaDataEnable,
+    BOOL     *Progressive,
+    uint32_t Reserved
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsFormatChange
+
+Description:
+
+    Changes codec type and parameters.
+
+    The device must have been previously opened for this call to succeed.
+    This function should be used only for mid-stream format changes.
+    DtsStartDecoder must have been called before for this function to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    videoAlg    Video Codec to be enabled to decode stream.
+                H.264 (0), VC-1 (4) and MPEG-2 (1) currently supported. All
+                other values will return BC_STS_INV_ARG
+    FGTEnable   Enable processing of FGT SEI.
+    Progressive Instruct decoder to always try to send back progressive
+                frames. If input content is 1080p, the decoder will ignore
+                pull-down flags and always give 1080p output. If 1080i
+                content is processed, the decoder will return 1080i data.
+                When this flag is not set, the decoder will use pull-down
+                information in the input stream to decide the decoded data
+                format.
+    Reserved    This field is reserved for possible future expansion.
+                Set to 0.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsFormatChange(
+    HANDLE   hDevice,
+    uint32_t videoAlg,
+    BOOL     FGTEnable,
+    BOOL     MetaDataEnable,
+    BOOL     Progressive,
+    uint32_t Reserved
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsStopDecoder
+
+Description:
+
+    Stop the decoder.
+
+    The device must have been previously opened for this call to succeed.
+    This function will clean up any pending operations and stop the decoder.
+    Internal state is still maintained and the decoder can be restarted.
+    Any pending pictures will be dropped.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStopDecoder(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsPauseDecoder
+
+Description:
+
+    Pause the decoder. The paused picture will be repeated by decoder.
+
+    The device must have been previously opened for this call to succeed.
+    In addition the decoder must have been started as well. If the decoder
+    is open but not started, this function will return BC_STS_DEC_NOT_STARTED.
+    If the decoder has not been opened this function will return
+    BC_STS_DEC_NOT_OPEN.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsPauseDecoder(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsResumeDecoder
+
+Description:
+
+    Unpause the decoder from a previous paused condition.
+
+    The device must have been previously opened for this call to succeed.
+    If the decoder was not paused previously, this function will return
+    without affecting the decoder with a BC_STS_SUCCESS status. If the
+    decoder is open but not started, this function will return
+    BC_STS_DEC_NOT_STARTED.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsResumeDecoder(
+    HANDLE  hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetVideoPID
+    
+Description:
+
+    Sets the video PID in the input Transport Stream that the decoder
+    needs to process.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice Handle to device. This is obtained via a prior call to
+            DtsDeviceOpen.
+    PID     PID value that decoder needs to process.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetVideoPID(
+    HANDLE    hDevice,
+    uint32_t  pid
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    StartCaptureImmidiate
+    
+Description:
+
+    Instruct the driver to start capturing decoded frames for output.
+
+    The device must have been previously opened for this call to succeed.
+    This function must be called before the first call to DtsProcInput.
+    This function instructs the receive path in the driver to start waiting
+    for valid data to be presented from the decoder.
+
+Parameters:
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsStartCaptureImmidiate(
+    HANDLE    hDevice,
+    uint32_t  Reserved
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    StartCapture
+
+Description:
+
+    Instruct the driver to start capturing decoded frames for output.
+
+    The device must have been previously opened for this call to succeed.
+    This function must be called before the first call to DtsProcInput.
+    This function instructs the receive path in the driver to start waiting
+    for valid data to be presented from the decoder.
+
+Parameters:
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStartCapture(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    FlushRxCapture
+
+Description:
+
+    ***This function is deprecated and is for temporary use only.***
+
+    Flush the driverís queue of pictures and stops the capture process. These
+    functions will be replaced with automatic Stop (End of Sequence) detection.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsFlushRxCapture(
+    HANDLE hDevice,
+    BOOL   bDiscardOnly
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsProcOutput
+
+Description:
+
+    Returns one decoded picture to the caller.
+
+    The device must have been previously opened for this call to succeed.
+
+    == NOTE ====
+        For PIB AND 100% output encryption/scrambling on Bcm LINK hardware
+    use ProcOutputNoCopy() Interace. This interface will not support
+    PIB encryption.
+
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    milliSecWait    Timeout parameter. DtsProcOutput will fail is no picture
+                    is received in this time.
+    *pOut           This is a pointer to the BC_DTS_PROC_OUT structure that is
+                    allocated by the caller. The decoded picture is returned
+                    in this structure. This structure is described in the
+                    data structures section. The actual data buffer to be
+                    filled with the decoded data is allocated by the caller.
+                    Data is copied from the decoder to the buffers before this
+                    function returns. [INPUT/OUTPUT]
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsProcOutput(
+    HANDLE   hDevice,
+    uint32_t milliSecWait,
+    BC_DTS_PROC_OUT *pOut
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsProcOutputNoCopy
+
+Description:
+
+    Returns one decoded picture to the caller. Functionality of this API()
+    is very similar to ProcOutPut() API. This API will not copy the video data
+    to caller's buffers but provides the source buffer pointers in pOut structure.
+
+    This is more secure and preferred method for BCM's Link hardware. The actual
+    format conversion/copy routines are provided as part of the Filter/Security
+    layer source code. Using this method, all the clear data handling will be
+    done by bcmDFilter or bcmSec layers which are expected to be in Player's
+    tamper resistant area.
+
+    == NOTE ====
+     1) DtsReleaseOutputBuffs() interface must be called to release the buffers
+        back to DIL if return Status is BC_STS_SUCCESS.
+
+     2) Only this interface supports PIB and full 100% output encryption/Scrambling.
+
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    milliSecWait    Timeout parameter. DtsProcOoutput will fail is no picture
+                    is received in this time.
+    *pOut           This is a pointer to the BC_DTS_PROC_OUT structure that is
+                    allocated by the caller. The decoded picture is returned
+                    in this structure.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsProcOutputNoCopy(
+    HANDLE   hDevice,
+    uint32_t milliSecWait,
+    BC_DTS_PROC_OUT *pOut
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsReleaseOutputBuffs
+
+Description:
+
+    Release Buffers acquired during ProcOutputNoCopy() interface.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    Reserved        Reserved. Set to NULL.
+
+    fChange         FALSE.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsReleaseOutputBuffs(
+    HANDLE hDevice,
+    PVOID  Reserved,
+    BOOL   fChange
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsProcInput
+
+Description:
+
+    Sends compressed (coded) data to the decoder for processing.
+
+    The device must have been previously opened for this call to succeed.
+    In addition, suitable keys must have been exchanged for decryption and
+    decode to be successful.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    pUserData   Pointer to data buffer that holds the data to be transferred.
+                [INPUT]
+    sizeInBytes Size in Bytes of data available to be sent to the decoder for
+                processing.
+    Timestamp   Optional timestamp information attached to the media sample
+                that is available in the buffer. If timestamp is present
+                (i.e. non-zero), then this will be reflected in the output
+                sample (picture) produced from the contents of this buffer.
+				Timestamp should be in units of 100 ns.
+    Encrypted   Flag to indicate that the data transfer is not in the clear
+                and that the decoder needs to decrypt before it can decode
+                the data.  Note that due to complexity, it is preferred that
+                the application writer uses the higher level
+                dts_pre_proc_input() call if encypted content will be sent.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsProcInput(
+    HANDLE   hDevice,
+    uint8_t  *pUserData,
+    uint32_t ulSizeInBytes,
+    uint64_t timeStamp,
+    BOOL     encrypted
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetColorPrimaries
+
+Description:
+
+    Returns color primaries information from the stream being processed.
+
+    The device must have been previously opened for this call to succeed.
+    In addition at least one picture must have been successfully decoded and
+    returned back from the decoder.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    colorPrimaries  Pointer to U32 to receive the color primaries information.
+                    The values returned are described in the previous section
+                    regarding the picture metadata. [OUTPUT]
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetColorPrimaries(
+    HANDLE    hDevice,
+    uint32_t  *colorPrimaries
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsFlushInput
+
+Description:
+
+    Flushes the current channel and causes the decoder to stop accessing input
+    data.  Based on the flush mode parameter, the channel will be flushed from
+    the current point in the input data or from the current processing point.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    Mode            0   Flush at the current input point. use to drain the
+                        input FIFO . All the data that has been received will
+                        be decoded.
+                    1   Flush at the current processing point. All the decoded
+                        frames will be presented but no more data from the
+                        input will be decoded.
+                    2   Flushes all the decoder buffers, input, decoded and
+                        to be decoded.
+                    3   Cancels the pending TX Request from the DIL/driver
+					4	Flushes all the decoder buffers, input, decoded and
+						to be decoded data. Also flushes the drivers buffers
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsFlushInput(
+    HANDLE   hDevice,
+    uint32_t Mode
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetRateChange
+
+Description:
+
+    Sets the decoder playback speed and direction of playback.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    rate            Inverse of speed x 10000.
+                    Examples:
+                        1/2x playback speed = 20000
+                        1x   playback speed = 10000
+                        2x   playback speed = 5000
+
+    direction       Playback direction.
+                    0   Forward direction.
+                    1   Reverse direction.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetRateChange(
+    HANDLE   hDevice,
+    uint32_t rate,
+    uint8_t  direction
+    );
+
+
+//Set FF Rate for Catching Up
+/*****************************************************************************
+
+Function name:
+
+    DtsSetFFRate
+
+Description:
+
+    Sets the decoder playback FF speed
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+    rate            Inverse of speed x 10000.
+                    Examples:
+                        1/2x playback speed = 20000
+                        1x   playback speed = 10000
+                        2x   playback speed = 5000
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetFFRate(
+    HANDLE   hDevice,
+    uint32_t rate
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetSkipPictureMode
+
+Description:
+
+    This command sets the decoder to only decode selected picture types.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+    SkipMode        0   IPB, All pictures are decoded.
+
+                    1   IP decoding, This mode skips all non reference pictures.
+
+                    2   I decoding, This mode skips all P/B pictures and only decodes
+                        I pictures.
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetSkipPictureMode(
+    HANDLE   hDevice,
+    uint32_t SkipMode
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetIFrameTrickMode
+
+Description:
+
+    This command sets the decoder to decode only I Frames for FF and FR.
+
+    Use this API for I Frame only trick mode play back in either direction. The
+    application/Up stream filter  determines the speed of the playback by
+    means of Skip on the input compressed data.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSetIFrameTrickMode(
+    HANDLE hDevice
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsStepDecoder
+
+Description:
+
+    This function forwards one frame.
+
+    The device must have been opened must be in paused
+    state previously for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsStepDecoder(
+    HANDLE hDevice
+    );
+
+
+/*****************************************************************************
+
+Function name:
+
+    DtsIs422Supported
+
+Description:
+
+    This function returns whether 422 YUV mode is supported or not.
+
+    The device must have been opened previously for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    bSupported  1 - 422 is supported
+                0 - 422 is not supported.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsIs422Supported(
+    HANDLE  hDevice,
+    uint8_t *bSupported
+    );
+
+/*****************************************************************************
+
+Function name:
+
+     DtsSetColorSpace    
+    
+Description:
+
+    This function sets the output sample's color space.
+
+    The device must have been opened previously and must support 422 mode for
+    this call to succeed.
+
+    Use "DtsIs422Supported" to find whether 422 mode is supported.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    422Mode     Mode is defined by BC_OUTPUT_FORMAT as follows -
+				OUTPUT_MODE420		= 0x0,
+				OUTPUT_MODE422_YUY2	= 0x1,
+				OUTPUT_MODE422_UYVY	= 0x2,
+				OUTPUT_MODE_INVALID	= 0xFF
+				Valid values for this API are OUTPUT_MODE422_YUY2 and OUTPUT_MODE422_UYVY
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetColorSpace(
+    HANDLE  hDevice,
+    BC_OUTPUT_FORMAT      Mode422
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSet422Mode
+
+Description:
+
+    This function sets the 422 mode to either YUY2 or UYVY.
+
+    The device must have been opened previously and must support 422 mode for
+    this call to succeed.
+
+    Use "DtsIs422Supported" to find whether 422 mode is supported.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+    422Mode     0 - set the YUV mode to YUY2
+                1 - set the YUV mode to UYVY
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsSet422Mode(
+    HANDLE  hDevice,
+    uint8_t Mode422
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetDILPath
+
+Description:
+
+    This is a helper function to return DIL's Path.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                DtsDeviceOpen.
+
+    DilPath     Buffer to hold DIL path info upto 256 bytes.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+
+DRVIFLIB_API BC_STATUS
+DtsGetDILPath(
+    HANDLE   hDevice,
+    char   *DilPath,
+    uint32_t size
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsDropPictures
+
+Description:
+
+    This command sets the decoder to skip one or more non-reference (B) pictures
+    in the input data stream.  This is used for when the audio is ahead of
+    video and the application needs to cause video to move ahead to catch up.
+    Reference pictures are not skipped.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+    Pictures        The number of non-reference pictures to drop.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsDropPictures(
+    HANDLE   hDevice,
+    uint32_t Pictures
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetDriverStatus
+
+Description:
+
+    This command returns various statistics related to the driver and DIL.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.
+
+    *pStatus        Pointer to BC_DTS_STATUS to receive driver status.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS
+DtsGetDriverStatus(
+    HANDLE          hDevice,
+	BC_DTS_STATUS   *pStatus
+    );
+
+/*****************************************************************************
+
+Function name:
+
+    DtsGetCapabilities
+
+Description:
+
+    This command returns output format support and hardware capabilities.
+
+    The device must have been previously opened for this call to succeed.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    pCapsBuffer   Pointer to BC_HW_CAPS to receive HW Output capabilities.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsGetCapabilities (
+	HANDLE  hDevice,
+	PBC_HW_CAPS	pCapsBuffer
+	);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsSetScaleParams
+
+Description:
+
+    This command sets hardware scaling parameters.
+
+Parameters:
+
+    hDevice         Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    pScaleParams   Pointer to BC_SCALING_PARAMS to set hardware scaling parameters.
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsSetScaleParams (
+	HANDLE  hDevice,
+	PBC_SCALING_PARAMS pScaleParams
+	);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsIsEndOfStream
+
+Description:
+
+    This command returns whether the end of stream(EOS) is reaching.
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    bEOS   Pointer to uint8_t to indicate if EOS of not
+
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsIsEndOfStream(
+    HANDLE  hDevice,
+    uint8_t*	bEOS
+);
+
+/*****************************************************************************
+
+Function name:
+
+    DtsCrystalHDVersion
+
+Description:
+
+    This API returns hw and sw version information for Crystal HD solutions
+Parameters:
+
+    hDevice     Handle to device. This is obtained via a prior call to
+                    DtsDeviceOpen.   
+
+    bCrystalInfo   Pointer to structure to fill in with information
+
+	device = 0 for BCM70012, 1 for BCM70015
+	
+Return:
+
+    BC_STS_SUCCESS will be returned on successful completion.
+
+*****************************************************************************/
+DRVIFLIB_API BC_STATUS 
+DtsCrystalHDVersion(
+    HANDLE  hDevice,
+    PBC_INFO_CRYSTAL bCrystalInfo
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_version.h b/tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_version.h
new file mode 100644
index 0000000..b640dac
--- /dev/null
+++ b/tools/depends/target/libcrystalhd/libcrystalhd/libcrystalhd_version.h
@@ -0,0 +1,80 @@
+/********************************************************************
+ * Copyright(c) 2006-2009 Broadcom Corporation.
+ *
+ *  Name: libcrystalhd_version.h
+ *
+ *  Description: Version numbering for the driver use.
+ *
+ *  AU
+ *
+ *  HISTORY:
+ *
+ ********************************************************************
+ * This header is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation, either version 2.1 of the License.
+ *
+ * This header is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this header.  If not, see <http://www.gnu.org/licenses/>.
+ *******************************************************************/
+
+#ifndef _BC_DTS_VERSION_LNX_
+#define _BC_DTS_VERSION_LNX_
+//
+// The version format that we are adopting is
+// MajorVersion.MinorVersion.Revision
+// This will be the same for all the components.
+//
+//
+#define STRINGIFY_VERSION(MAJ,MIN,REV) STRINGIFIED_VERSION(MAJ,MIN,REV)
+#define STRINGIFIED_VERSION(MAJ,MIN,REV) #MAJ "." #MIN "." #REV
+
+#define STRINGIFY_VERSION_W(MAJ,MIN,REV) STRINGIFIED_VERSION_W(MAJ,MIN,REV)
+#define STRINGIFIED_VERSION_W(MAJ,MIN,REV) #MAJ "." #MIN "." #REV
+
+//
+//  Product Version number is:
+//  x.y.z.a
+//
+//  x = Major release.      1 = Dozer, 2 = Dozer + Link
+//  y = Minor release.      Should increase +1 per "real" release.
+//  z = Branch release.     0 for main branch.  This is +1 per branch release.
+//  a = Build number	+1 per candidate release.  Reset to 0 every "real" release.
+//
+//
+// Enabling Check-In rules enforcement 08092007
+//
+#define INVALID_VERSION		0xFFFF
+
+/*========================== Common For All Components =================================*/
+#define BRCM_MAJOR_VERSION	3
+
+#define DRIVER_MAJOR_VERSION        BRCM_MAJOR_VERSION
+#define DRIVER_MINOR_VERSION        6
+#define DRIVER_REVISION             0
+
+#define RC_FILE_VERSION             STRINGIFY_VERSION(DRIVER_MAJOR_VERSION,DRIVER_MINOR_VERSION,DRIVER_REVISION) ".0"
+
+/*======================= Device Interface Library ========================*/
+#define DIL_MAJOR_VERSION	BRCM_MAJOR_VERSION
+#define DIL_MINOR_VERSION	6
+#define DIL_REVISION		0
+
+#define DIL_RC_FILE_VERSION	STRINGIFY_VERSION(DIL_MAJOR_VERSION,DIL_MINOR_VERSION,DIL_REVISION)
+
+/*========================== deconf utility ==============================*/
+#define DECONF_MAJOR_VERSION	BRCM_MAJOR_VERSION
+#define DECONF_MINOR_VERSION	9
+#define DECONF_REVISION		18
+#define DECONF_RC_FILE_VERSION  STRINGIFY_VERSION(DIL_MAJOR_VERSION,DIL_MINOR_VERSION,DIL_REVISION)
+
+/*========================== Firmware ==============================*/
+#define FW_MAJOR_VERSION        BRCM_MAJOR_VERSION
+#define FW_MINOR_VERSION        60
+#define FW_REVISION		39
+
+#endif
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index bc6f4a2..e4adcae 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -130,6 +130,9 @@
 #ifdef HAS_JSONRPC
 #include "interfaces/json-rpc/JSONRPC.h"
 #endif
+#if defined(HAVE_LIBCRYSTALHD)
+#include "cores/dvdplayer/DVDCodecs/Video/CrystalHD.h"
+#endif
 #include "interfaces/AnnouncementManager.h"
 #include "peripherals/Peripherals.h"
 #include "peripherals/dialogs/GUIDialogPeripheralManager.h"
@@ -1229,6 +1232,10 @@ bool CApplication::Initialize()
 
   m_slowTimer.StartZero();
 
+#if defined(HAVE_LIBCRYSTALHD)
+  CCrystalHD::GetInstance();
+#endif
+
   CAddonMgr::Get().StartServices(true);
 
   // configure seek handler
@@ -2679,6 +2686,10 @@ void CApplication::Stop(int exitCode)
       XBMCHelper::GetInstance().Stop();
 #endif
 
+#if defined(HAVE_LIBCRYSTALHD)
+    CCrystalHD::RemoveInstance();
+#endif
+
     g_mediaManager.Stop();
 
     // Stop services before unloading Python
diff --git a/xbmc/DllPaths_generated.h.in b/xbmc/DllPaths_generated.h.in
index c92a8bd..a98058c 100644
--- a/xbmc/DllPaths_generated.h.in
+++ b/xbmc/DllPaths_generated.h.in
@@ -46,6 +46,17 @@
 #define DLL_PATH_LIBDVDNAV     "special://xbmcbin/system/players/dvdplayer/libdvdnav-@ARCH@.so"
 #define DLL_PATH_LIBMPEG2      "@MPEG2_SONAME@"
 
+/* cdrip */
+#define DLL_PATH_OGG           "@OGG_SONAME@"
+#define DLL_PATH_VORBIS        "@VORBIS_SONAME@"
+
+/* broadcom crystalhd */
+#if defined(TARGET_DARWIN)
+#define DLL_PATH_LIBCRYSTALHD  "libcrystalhd.dylib"
+#else
+#define DLL_PATH_LIBCRYSTALHD  "@CRYSTALHD_SONAME@"
+#endif
+
 /* libbluray */
 #define DLL_PATH_LIBBLURAY     "@BLURAY_SONAME@"
 
diff --git a/xbmc/DllPaths_win32.h b/xbmc/DllPaths_win32.h
index c5026ac..066543c 100644
--- a/xbmc/DllPaths_win32.h
+++ b/xbmc/DllPaths_win32.h
@@ -36,6 +36,7 @@
 #define DLL_PATH_LIBASS        "special://xbmcbin/system/players/dvdplayer/libass.dll"
 #define DLL_PATH_LIBMPEG2      "special://xbmcbin/system/players/dvdplayer/libmpeg2-0.dll"
 #define DLL_PATH_LIBDVDNAV     "special://xbmcbin/system/players/dvdplayer/libdvdnav.dll"
+#define DLL_PATH_LIBCRYSTALHD  "special://xbmcbin/system/players/dvdplayer/bcmDIL.dll"
 #define DLL_PATH_LIBRTMP       "special://xbmcbin/system/players/dvdplayer/librtmp.dll"
 
 /* cdrip */
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 4c363cf..4bafec4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -42,6 +42,9 @@
 #endif
 #include "Video/MMALCodec.h"
 #include "Video/DVDVideoCodecStageFright.h"
+#if defined(HAVE_LIBCRYSTALHD)
+#include "Video/DVDVideoCodecCrystalHD.h"
+#endif
 #if defined(HAS_LIBAMCODEC)
 #include "utils/AMLUtils.h"
 #include "Video/DVDVideoCodecAmlogic.h"
@@ -154,6 +157,11 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
 #elif defined(TARGET_DARWIN)
   hwSupport += "VideoToolBoxDecoder:no ";
 #endif
+#ifdef HAVE_LIBCRYSTALHD
+  hwSupport += "CrystalHD:yes ";
+#else
+  hwSupport += "CrystalHD:no ";
+#endif
 #if defined(HAS_LIBAMCODEC)
   hwSupport += "AMCodec:yes ";
 #else
@@ -262,6 +270,23 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
   }
 #endif
 
+#if defined(HAVE_LIBCRYSTALHD)
+  if (!hint.software && CSettings::Get().GetBool("videoplayer.usechd"))
+  {
+    if (CCrystalHD::GetInstance()->DevicePresent())
+    {
+      switch(hint.codec)
+      {
+        case AV_CODEC_ID_H264:
+          if ( (pCodec = OpenCodec(new CDVDVideoCodecCrystalHD(), hint, options)) ) return pCodec;
+        break;
+        default:
+        break;
+      }
+    }
+  }
+#endif
+
 #if defined(TARGET_ANDROID)
   if (!hint.software && CSettings::Get().GetBool("videoplayer.usemediacodec"))
   {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp
new file mode 100644
index 0000000..586b45b
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp
@@ -0,0 +1,2010 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if defined(TARGET_WINDOWS)
+#include "WIN32Util.h"
+#include "util.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "guilib/LocalizeStrings.h"
+#endif
+
+#if defined(HAVE_LIBCRYSTALHD)
+#include "CrystalHD.h"
+
+#include "DVDClock.h"
+#include "DynamicDll.h"
+#include "utils/SystemInfo.h"
+#include "threads/Atomics.h"
+#include "threads/Thread.h"
+#include "utils/log.h"
+extern "C" {
+#include "libswscale/swscale.h"
+}
+#include "utils/TimeUtils.h"
+#include "windowing/WindowingFactory.h"
+#include "cores/FFmpeg.h"
+
+namespace BCM
+{
+  #if defined(TARGET_WINDOWS)
+    typedef void		*HANDLE;
+  #else
+    #ifndef __LINUX_USER__
+      #define __LINUX_USER__
+    #endif
+  #endif
+
+  #include <libcrystalhd/bc_dts_types.h>
+  #include <libcrystalhd/bc_dts_defs.h>
+  #include <libcrystalhd/libcrystalhd_if.h>
+};
+
+#define __MODULE_NAME__ "CrystalHD"
+//#define USE_CHD_SINGLE_THREADED_API
+class DllLibCrystalHDInterface
+{
+public:
+  virtual ~DllLibCrystalHDInterface() {}
+  virtual BCM::BC_STATUS DtsDeviceOpen(void *hDevice, uint32_t mode)=0;
+  virtual BCM::BC_STATUS DtsDeviceClose(void *hDevice)=0;
+  virtual BCM::BC_STATUS DtsOpenDecoder(void *hDevice, uint32_t StreamType)=0;
+  virtual BCM::BC_STATUS DtsCloseDecoder(void *hDevice)=0;
+  virtual BCM::BC_STATUS DtsStartDecoder(void *hDevice)=0;
+  virtual BCM::BC_STATUS DtsSetVideoParams(void *hDevice, uint32_t videoAlg, int FGTEnable, int MetaDataEnable, int Progressive, uint32_t OptFlags)=0;
+  virtual BCM::BC_STATUS DtsStartCapture(void *hDevice)=0;
+  virtual BCM::BC_STATUS DtsFlushRxCapture(void *hDevice, int bDiscardOnly)=0;
+  virtual BCM::BC_STATUS DtsSetFFRate(void *hDevice, uint32_t rate)=0;
+  virtual BCM::BC_STATUS DtsGetDriverStatus(void *hDevice, BCM::BC_DTS_STATUS *pStatus)=0;
+  virtual BCM::BC_STATUS DtsProcInput(void *hDevice, uint8_t *pUserData, uint32_t ulSizeInBytes, uint64_t timeStamp, int encrypted)=0;
+  virtual BCM::BC_STATUS DtsProcOutput(void *hDevice, uint32_t milliSecWait, BCM::BC_DTS_PROC_OUT *pOut)=0;
+  virtual BCM::BC_STATUS DtsProcOutputNoCopy(void *hDevice, uint32_t milliSecWait, BCM::BC_DTS_PROC_OUT *pOut)=0;
+  virtual BCM::BC_STATUS DtsReleaseOutputBuffs(void *hDevice, void *Reserved, int fChange)=0;
+  virtual BCM::BC_STATUS DtsSetSkipPictureMode(void *hDevice, uint32_t Mode)=0;
+  virtual BCM::BC_STATUS DtsFlushInput(void *hDevice, uint32_t SkipMode)=0;
+
+#if (HAVE_LIBCRYSTALHD == 2)
+  // new function calls, only present in new driver/library so manually load them
+  virtual BCM::BC_STATUS DtsGetVersion(void *hDevice, uint32_t *DrVer, uint32_t *DilVer)=0;
+  virtual BCM::BC_STATUS DtsSetInputFormat(void *hDevice, BCM::BC_INPUT_FORMAT *pInputFormat)=0;
+  virtual BCM::BC_STATUS DtsGetColorPrimaries(void *hDevice, uint32_t *colorPrimaries)=0;
+  virtual BCM::BC_STATUS DtsSetColorSpace(void *hDevice, BCM::BC_OUTPUT_FORMAT Mode422)=0;
+  virtual BCM::BC_STATUS DtsGetCapabilities(void *hDevice, BCM::BC_HW_CAPS *CapsBuffer)=0;
+  virtual BCM::BC_STATUS DtsSetScaleParams(void *hDevice, BCM::BC_SCALING_PARAMS *ScaleParams)=0;
+  virtual BCM::BC_STATUS DtsIsEndOfStream(void *hDevice, uint8_t* bEOS)=0;
+  virtual BCM::BC_STATUS DtsCrystalHDVersion(void *hDevice, BCM::BC_INFO_CRYSTAL *CrystalInfo)=0;
+#endif
+};
+
+class DllLibCrystalHD : public DllDynamic, DllLibCrystalHDInterface
+{
+  DECLARE_DLL_WRAPPER(DllLibCrystalHD, DLL_PATH_LIBCRYSTALHD)
+
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsDeviceOpen,      (void *p1, uint32_t p2))
+  DEFINE_METHOD1(BCM::BC_STATUS, DtsDeviceClose,     (void *p1))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsOpenDecoder,     (void *p1, uint32_t p2))
+  DEFINE_METHOD1(BCM::BC_STATUS, DtsCloseDecoder,    (void *p1))
+  DEFINE_METHOD1(BCM::BC_STATUS, DtsStartDecoder,    (void *p1))
+  DEFINE_METHOD1(BCM::BC_STATUS, DtsStopDecoder,     (void *p1))
+  DEFINE_METHOD6(BCM::BC_STATUS, DtsSetVideoParams,  (void *p1, uint32_t p2, int p3, int p4, int p5, uint32_t p6))
+  DEFINE_METHOD1(BCM::BC_STATUS, DtsStartCapture,    (void *p1))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsFlushRxCapture,  (void *p1, int p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsSetFFRate,       (void *p1, uint32_t p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsGetDriverStatus, (void *p1, BCM::BC_DTS_STATUS *p2))
+  DEFINE_METHOD5(BCM::BC_STATUS, DtsProcInput,       (void *p1, uint8_t *p2, uint32_t p3, uint64_t p4, int p5))
+  DEFINE_METHOD3(BCM::BC_STATUS, DtsProcOutput,      (void *p1, uint32_t p2, BCM::BC_DTS_PROC_OUT *p3))
+  DEFINE_METHOD3(BCM::BC_STATUS, DtsProcOutputNoCopy,(void *p1, uint32_t p2, BCM::BC_DTS_PROC_OUT *p3))
+  DEFINE_METHOD3(BCM::BC_STATUS, DtsReleaseOutputBuffs,(void *p1, void *p2, int p3))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsSetSkipPictureMode,(void *p1, uint32_t p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsFlushInput,      (void *p1, uint32_t p2))
+
+#if (HAVE_LIBCRYSTALHD == 2)
+  DEFINE_METHOD3(BCM::BC_STATUS, DtsGetVersion,      (void *p1, uint32_t *p2, uint32_t *p3))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsSetInputFormat,  (void *p1, BCM::BC_INPUT_FORMAT *p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsGetColorPrimaries,(void *p1, uint32_t *p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsSetColorSpace,   (void *p1, BCM::BC_OUTPUT_FORMAT p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsGetCapabilities, (void *p1, BCM::BC_HW_CAPS *p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsSetScaleParams,  (void *p1, BCM::BC_SCALING_PARAMS *p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsIsEndOfStream,   (void *p1, uint8_t *p2))
+  DEFINE_METHOD2(BCM::BC_STATUS, DtsCrystalHDVersion,(void *p1, BCM::BC_INFO_CRYSTAL *p2))
+#endif
+
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD_RENAME(DtsDeviceOpen,      DtsDeviceOpen)
+    RESOLVE_METHOD_RENAME(DtsDeviceClose,     DtsDeviceClose)
+    RESOLVE_METHOD_RENAME(DtsOpenDecoder,     DtsOpenDecoder)
+    RESOLVE_METHOD_RENAME(DtsCloseDecoder,    DtsCloseDecoder)
+    RESOLVE_METHOD_RENAME(DtsStartDecoder,    DtsStartDecoder)
+    RESOLVE_METHOD_RENAME(DtsStopDecoder,     DtsStopDecoder)
+    RESOLVE_METHOD_RENAME(DtsSetVideoParams,  DtsSetVideoParams)
+    RESOLVE_METHOD_RENAME(DtsStartCapture,    DtsStartCapture)
+    RESOLVE_METHOD_RENAME(DtsFlushRxCapture,  DtsFlushRxCapture)
+    RESOLVE_METHOD_RENAME(DtsSetFFRate,       DtsSetFFRate)
+    RESOLVE_METHOD_RENAME(DtsGetDriverStatus, DtsGetDriverStatus)
+    RESOLVE_METHOD_RENAME(DtsProcInput,       DtsProcInput)
+    RESOLVE_METHOD_RENAME(DtsProcOutput,      DtsProcOutput)
+    RESOLVE_METHOD_RENAME(DtsProcOutputNoCopy,DtsProcOutputNoCopy)
+    RESOLVE_METHOD_RENAME(DtsReleaseOutputBuffs,DtsReleaseOutputBuffs)
+    RESOLVE_METHOD_RENAME(DtsSetSkipPictureMode,DtsSetSkipPictureMode)
+    RESOLVE_METHOD_RENAME(DtsFlushInput,      DtsFlushInput)
+  END_METHOD_RESOLVE()
+  
+public:
+  bool LoadNewLibFunctions(void)
+  {
+#if (HAVE_LIBCRYSTALHD == 2)
+    int rtn;
+    rtn  = m_dll->ResolveExport("DtsGetVersion",       (void**)&m_DtsGetVersion_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsSetInputFormat",   (void**)&m_DtsSetInputFormat_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsGetColorPrimaries",(void**)&m_DtsGetColorPrimaries_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsSetColorSpace",    (void**)&m_DtsSetColorSpace_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsGetCapabilities",  (void**)&m_DtsGetCapabilities_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsSetScaleParams",   (void**)&m_DtsSetScaleParams_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsIsEndOfStream",    (void**)&m_DtsIsEndOfStream_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsCrystalHDVersion", (void**)&m_DtsCrystalHDVersion_ptr, false);
+    rtn &= m_dll->ResolveExport("DtsSetInputFormat",   (void**)&m_DtsSetInputFormat_ptr, false);
+    return(rtn == 1);
+#else
+    return false;
+#endif
+  };
+};
+
+void PrintFormat(BCM::BC_PIC_INFO_BLOCK &pib);
+void BcmDebugLog( BCM::BC_STATUS lResult, std::string strFuncName="");
+
+const char* g_DtsStatusText[] = {
+	"BC_STS_SUCCESS",
+	"BC_STS_INV_ARG",
+	"BC_STS_BUSY",		
+	"BC_STS_NOT_IMPL",		
+	"BC_STS_PGM_QUIT",		
+	"BC_STS_NO_ACCESS",	
+	"BC_STS_INSUFF_RES",	
+	"BC_STS_IO_ERROR",		
+	"BC_STS_NO_DATA",		
+	"BC_STS_VER_MISMATCH",
+	"BC_STS_TIMEOUT",		
+	"BC_STS_FW_CMD_ERR",	
+	"BC_STS_DEC_NOT_OPEN",
+	"BC_STS_ERR_USAGE",
+	"BC_STS_IO_USER_ABORT",
+	"BC_STS_IO_XFR_ERROR",
+	"BC_STS_DEC_NOT_STARTED",
+	"BC_STS_FWHEX_NOT_FOUND",
+	"BC_STS_FMT_CHANGE",
+	"BC_STS_HIF_ACCESS",
+	"BC_STS_CMD_CANCELLED",
+	"BC_STS_FW_AUTH_FAILED",
+	"BC_STS_BOOTLOADER_FAILED",
+	"BC_STS_CERT_VERIFY_ERROR",
+	"BC_STS_DEC_EXIST_OPEN",
+	"BC_STS_PENDING",
+	"BC_STS_CLK_NOCHG"
+};
+
+////////////////////////////////////////////////////////////////////////////////////////////
+class CMPCOutputThread : public CThread
+{
+public:
+  CMPCOutputThread(void *device, DllLibCrystalHD *dll, bool has_bcm70015);
+  virtual ~CMPCOutputThread();
+
+  unsigned int        GetReadyCount(void);
+  unsigned int        GetFreeCount(void);
+  CPictureBuffer*     ReadyListPop(void);
+  void                FreeListPush(CPictureBuffer* pBuffer);
+  bool                WaitOutput(unsigned int msec);
+
+protected:
+  void                DoFrameRateTracking(double timestamp);
+  void                SetFrameRate(uint32_t resolution);
+  void                SetAspectRatio(BCM::BC_PIC_INFO_BLOCK *pic_info);
+  void                CopyOutAsNV12(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride);
+  void                CopyOutAsNV12DeInterlace(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride);
+  void                CopyOutAsYV12(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride);
+  void                CopyOutAsYV12DeInterlace(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride);
+  void                CheckUpperLeftGreenPixelHack(CPictureBuffer *pBuffer);
+  bool                GetDecoderOutput(void);
+  virtual void        Process(void);
+
+  CSyncPtrQueue<CPictureBuffer> m_FreeList;
+  CSyncPtrQueue<CPictureBuffer> m_ReadyList;
+
+  DllLibCrystalHD     *m_dll;
+  void                *m_device;
+  bool                m_has_bcm70015;
+  unsigned int        m_timeout;
+  bool                m_format_valid;
+  bool                m_is_live_stream;
+  int                 m_width;
+  int                 m_height;
+  uint64_t            m_timestamp;
+  bool                m_output_YV12;
+  uint64_t            m_PictureNumber;
+  uint8_t             m_color_space;
+  unsigned int        m_color_range;
+  unsigned int        m_color_matrix;
+  int                 m_interlace;
+  bool                m_framerate_tracking;
+  uint64_t            m_framerate_cnt;
+  double              m_framerate_timestamp;
+  double              m_framerate;
+  int                 m_aspectratio_x;
+  int                 m_aspectratio_y;
+  CEvent              m_ready_event;
+  struct SwsContext   *m_sw_scale_ctx;
+};
+
+////////////////////////////////////////////////////////////////////////////////////////////
+#if defined(TARGET_DARWIN)
+#pragma mark -
+#endif
+CPictureBuffer::CPictureBuffer(ERenderFormat format, int width, int height)
+{
+  m_width = width;
+  m_height = height;
+  m_field = CRYSTALHD_FIELD_FULL;
+  m_interlace = false;
+  m_timestamp = DVD_NOPTS_VALUE;
+  m_PictureNumber = 0;
+  m_color_space = BCM::MODE420;
+  m_color_range = 0;
+  m_color_matrix = 4;
+  m_format = format;
+  m_framerate = 0;
+  
+  switch(m_format)
+  {
+    default:
+    case RENDER_FMT_NV12:
+      // setup y plane
+      m_y_buffer_size = m_width * m_height;
+      m_y_buffer_ptr = (unsigned char*)_aligned_malloc(m_y_buffer_size, 16);
+  
+      m_u_buffer_size = 0;
+      m_v_buffer_size = 0;
+      m_u_buffer_ptr = NULL;
+      m_v_buffer_ptr = NULL;
+      m_uv_buffer_size = m_y_buffer_size / 2;
+      m_uv_buffer_ptr = (unsigned char*)_aligned_malloc(m_uv_buffer_size, 16);
+    break;
+    case RENDER_FMT_YUYV422:
+      // setup y plane
+      m_y_buffer_size = (2 * m_width) * m_height;
+      m_y_buffer_ptr = (unsigned char*)_aligned_malloc(m_y_buffer_size, 16);
+  
+      m_uv_buffer_size = 0;
+      m_uv_buffer_ptr = NULL;
+      m_u_buffer_size = 0;
+      m_v_buffer_size = 0;
+      m_u_buffer_ptr = NULL;
+      m_v_buffer_ptr = NULL;
+    break;
+    case RENDER_FMT_YUV420P:
+      // setup y plane
+      m_y_buffer_size = m_width * m_height;
+      m_y_buffer_ptr = (unsigned char*)_aligned_malloc(m_y_buffer_size, 16);
+  
+      m_uv_buffer_size = 0;
+      m_uv_buffer_ptr = NULL;
+      m_u_buffer_size = m_y_buffer_size / 4;
+      m_v_buffer_size = m_y_buffer_size / 4;
+      m_u_buffer_ptr = (unsigned char*)_aligned_malloc(m_u_buffer_size, 16);
+      m_v_buffer_ptr = (unsigned char*)_aligned_malloc(m_v_buffer_size, 16);
+    break;
+  }
+}
+
+CPictureBuffer::~CPictureBuffer()
+{
+  if (m_y_buffer_ptr) _aligned_free(m_y_buffer_ptr);
+  if (m_u_buffer_ptr) _aligned_free(m_u_buffer_ptr);
+  if (m_v_buffer_ptr) _aligned_free(m_v_buffer_ptr);
+  if (m_uv_buffer_ptr) _aligned_free(m_uv_buffer_ptr);
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+#if defined(TARGET_DARWIN)
+#pragma mark -
+#endif
+CMPCOutputThread::CMPCOutputThread(void *device, DllLibCrystalHD *dll, bool has_bcm70015) :
+  CThread("MPCOutput"),
+  m_dll(dll),
+  m_device(device),
+  m_has_bcm70015(has_bcm70015),
+  m_timeout(20),
+  m_format_valid(false),
+  m_is_live_stream(false),
+  m_width(0),
+  m_height(0),
+  m_timestamp(0),
+  m_PictureNumber(0),
+  m_color_space(0),
+  m_color_range(0),
+  m_color_matrix(0),
+  m_interlace(0),
+  m_framerate_tracking(false),
+  m_framerate_cnt(0),
+  m_framerate_timestamp(0.0),
+  m_framerate(0.0),
+  m_aspectratio_x(1),
+  m_aspectratio_y(1)
+{
+  m_sw_scale_ctx = NULL;
+  
+  if (g_Windowing.GetRenderQuirks() & RENDER_QUIRKS_YV12_PREFERED)
+    m_output_YV12 = true;
+  else
+    m_output_YV12 = false;
+}
+
+CMPCOutputThread::~CMPCOutputThread()
+{
+  while(m_ReadyList.Count())
+    delete m_ReadyList.Pop();
+  while(m_FreeList.Count())
+    delete m_FreeList.Pop();
+    
+  if (m_sw_scale_ctx)
+    sws_freeContext(m_sw_scale_ctx);
+}
+
+unsigned int CMPCOutputThread::GetReadyCount(void)
+{
+  return m_ReadyList.Count();
+}
+
+unsigned int CMPCOutputThread::GetFreeCount(void)
+{
+  return m_FreeList.Count();
+}
+
+CPictureBuffer* CMPCOutputThread::ReadyListPop(void)
+{
+  CPictureBuffer *pBuffer = m_ReadyList.Pop();
+  return pBuffer;
+}
+
+void CMPCOutputThread::FreeListPush(CPictureBuffer* pBuffer)
+{
+  m_FreeList.Push(pBuffer);
+}
+
+bool CMPCOutputThread::WaitOutput(unsigned int msec)
+{
+  return m_ready_event.WaitMSec(msec);
+}
+
+void CMPCOutputThread::DoFrameRateTracking(double timestamp)
+{
+  if (timestamp != DVD_NOPTS_VALUE)
+  {
+    double duration;
+    // if timestamp does not start at a low value we 
+    // came in the middle of an online live stream
+    // 250 ms is a fourth of a 25fps source
+    // if timestamp is larger than that at the beginning
+    // we are much more out of sync than with the rough 
+    // calculation. To cover these 250 ms we need
+    // roughly 5 seconds of video stream to get back
+    // in sync
+    if (m_framerate_cnt == 0 && timestamp > 250000.0)
+      m_is_live_stream = true;
+    
+    duration = timestamp - m_framerate_timestamp;
+    if (duration > 0.0)
+    {
+      double framerate;
+      // cnt count has to be done here, cause we miss frames
+      // if framerate will not calculated correctly and
+      // duration has to be > 0.0 so we do not calc images twice
+      m_framerate_cnt++;
+
+      m_framerate_timestamp += duration;
+      framerate = DVD_TIME_BASE / duration;
+      // qualify framerate, we don't care about absolute value, just
+      // want to to verify range. Timestamp could be borked so ignore
+      // anything that does not verify.
+      // 60, 59.94 -> 60
+      // 50, 49.95 -> 50
+      // 30, 29.97 -> 30
+      // 25, 24.975 -> 25
+      // 24, 23.976 -> 24
+      switch ((int)(0.5 + framerate))
+      {
+        case 60:
+        case 50:
+        case 30:
+        case 25:
+        case 24:
+          // if we have such a live stream framerate is more exact than calculating
+          // cause of m_framerate_cnt and timestamp do not match in any way
+          m_framerate = m_is_live_stream ? framerate : DVD_TIME_BASE / (m_framerate_timestamp/m_framerate_cnt);
+        break;
+      }
+    }
+  }
+}
+
+void CMPCOutputThread::SetFrameRate(uint32_t resolution)
+{
+  m_interlace = FALSE;
+
+  switch (resolution)
+  {
+    case BCM::vdecRESOLUTION_1080p30:
+      m_framerate = 30.0;
+    break;
+    case BCM::vdecRESOLUTION_1080p29_97:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_1080p25 :
+      m_framerate = 25.0;
+    break;
+    case BCM::vdecRESOLUTION_1080p24:
+      m_framerate = 24.0;
+    break;
+    case BCM::vdecRESOLUTION_1080p23_976:
+      m_framerate = 24.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_1080p0:
+      // 1080p0 is ambiguious, could be 23.976 or 29.97 fps, decoder
+      // just does not know. 1080p@23_976 is more common but this
+      // will mess up 1080p@29_97 playback. We really need to verify
+      // which framerate with duration tracking.
+      m_framerate_tracking = true;
+      m_framerate = 24.0 * 1000.0 / 1001.0;
+    break;
+    
+    case BCM::vdecRESOLUTION_1080i29_97:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    case BCM::vdecRESOLUTION_1080i0:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    case BCM::vdecRESOLUTION_1080i:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    case BCM::vdecRESOLUTION_1080i25:
+      m_framerate = 25.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    
+    case BCM::vdecRESOLUTION_720p59_94:
+      m_framerate = 60.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_720p:
+      m_framerate = 60.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_720p50:
+      m_framerate = 50.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_720p29_97:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_720p24:
+      m_framerate = 24.0;
+    break;
+    case BCM::vdecRESOLUTION_720p23_976:
+      // some 720p/25 will be identifed as this, enable tracking.
+      m_framerate_tracking = true;
+      m_framerate = 24.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_720p0:
+      // 720p0 is ambiguious, could be 23.976, 29.97 or 59.97 fps, decoder
+      // just does not know. 720p@23_976 is more common but this
+      // will mess up other playback. We really need to verify
+      // which framerate with duration tracking.
+      m_framerate_tracking = true;
+      m_framerate = 24.0 * 1000.0 / 1001.0;
+    break;
+    
+    case BCM::vdecRESOLUTION_576p25:
+      m_framerate = 25.0;
+    break;
+    case BCM::vdecRESOLUTION_576p0:
+      m_framerate = 25.0;
+    break;
+    case BCM::vdecRESOLUTION_PAL1:
+      m_framerate = 25.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    
+    case BCM::vdecRESOLUTION_480p0:
+      m_framerate = 60.0;
+    break;
+    case BCM::vdecRESOLUTION_480p:
+      m_framerate = 60.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_480p29_97:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+    break;
+    case BCM::vdecRESOLUTION_480p23_976:
+      m_framerate = 24.0 * 1000.0 / 1001.0;
+    break;
+    
+    case BCM::vdecRESOLUTION_480i0:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    case BCM::vdecRESOLUTION_480i:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    case BCM::vdecRESOLUTION_NTSC:
+      m_framerate = 30.0 * 1000.0 / 1001.0;
+      m_interlace = TRUE;
+    break;
+    
+    default:
+      m_framerate_tracking = true;
+      m_framerate = 24.0 * 1000.0 / 1001.0;
+    break;
+  }
+
+  CLog::Log(LOGDEBUG, "%s: resolution = %x  interlace = %d", __MODULE_NAME__, resolution, m_interlace);
+}
+
+void CMPCOutputThread::SetAspectRatio(BCM::BC_PIC_INFO_BLOCK *pic_info)
+{
+	switch(pic_info->aspect_ratio)
+  {
+    case BCM::vdecAspectRatioSquare:
+      m_aspectratio_x = 1;
+      m_aspectratio_y = 1;
+    break;
+    case BCM::vdecAspectRatio12_11:
+      m_aspectratio_x = 12;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio10_11:
+      m_aspectratio_x = 10;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio16_11:
+      m_aspectratio_x = 16;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio40_33:
+      m_aspectratio_x = 40;
+      m_aspectratio_y = 33;
+    break;
+    case BCM::vdecAspectRatio24_11:
+      m_aspectratio_x = 24;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio20_11:
+      m_aspectratio_x = 20;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio32_11:
+      m_aspectratio_x = 32;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio80_33:
+      m_aspectratio_x = 80;
+      m_aspectratio_y = 33;
+    break;
+    case BCM::vdecAspectRatio18_11:
+      m_aspectratio_x = 18;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio15_11:
+      m_aspectratio_x = 15;
+      m_aspectratio_y = 11;
+    break;
+    case BCM::vdecAspectRatio64_33:
+      m_aspectratio_x = 64;
+      m_aspectratio_y = 33;
+    break;
+    case BCM::vdecAspectRatio160_99:
+      m_aspectratio_x = 160;
+      m_aspectratio_y = 99;
+    break;
+    case BCM::vdecAspectRatio4_3:
+      m_aspectratio_x = 4;
+      m_aspectratio_y = 3;
+    break;
+    case BCM::vdecAspectRatio16_9:
+      m_aspectratio_x = 16;
+      m_aspectratio_y = 9;
+    break;
+    case BCM::vdecAspectRatio221_1:
+      m_aspectratio_x = 221;
+      m_aspectratio_y = 1;
+    break;
+    case BCM::vdecAspectRatioUnknown:
+      m_aspectratio_x = 0;
+      m_aspectratio_y = 0;
+    break;
+
+    case BCM::vdecAspectRatioOther:
+      m_aspectratio_x = pic_info->custom_aspect_ratio_width_height & 0x0000ffff;
+      m_aspectratio_y = pic_info->custom_aspect_ratio_width_height >> 16;
+    break;
+  }
+  if(m_aspectratio_x == 0)
+  {
+    m_aspectratio_x = 1;
+    m_aspectratio_y = 1;
+  }
+
+  CLog::Log(LOGDEBUG, "%s: dec_par x = %d, dec_par y = %d", __MODULE_NAME__, m_aspectratio_x, m_aspectratio_y);
+}
+
+void CMPCOutputThread::CopyOutAsYV12(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride)
+{
+  // copy y
+  if (w == stride)
+  {
+    memcpy(pBuffer->m_y_buffer_ptr, procOut->Ybuff, w * h);
+  }
+  else
+  {
+    uint8_t *s_y = procOut->Ybuff;
+    uint8_t *d_y = pBuffer->m_y_buffer_ptr;
+    for (int y = 0; y < h; y++, s_y += stride, d_y += w)
+      memcpy(d_y, s_y, w);
+  }
+  //copy chroma
+  //copy uv packed to u,v planes (1/2 the width and 1/2 the height of y)
+  uint8_t *d_u = pBuffer->m_u_buffer_ptr;
+  uint8_t *d_v = pBuffer->m_v_buffer_ptr;
+  for (int y = 0; y < h/2; y++)
+  {
+    uint8_t *s_uv = procOut->UVbuff + (y * stride);
+    for (int x = 0; x < w/2; x++)
+    {
+      *d_u++ = *s_uv++;
+      *d_v++ = *s_uv++;
+    }
+  }
+}
+
+void CMPCOutputThread::CopyOutAsYV12DeInterlace(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride)
+{
+  // copy luma
+  uint8_t *s_y = procOut->Ybuff;
+  uint8_t *d_y = pBuffer->m_y_buffer_ptr;
+  for (int y = 0; y < h/2; y++, s_y += stride)
+  {
+    memcpy(d_y, s_y, w);
+    d_y += w;
+    memcpy(d_y, s_y, w);
+    d_y += w;
+  }
+  //copy chroma
+  //copy uv packed to u,v planes (1/2 the width and 1/2 the height of y)
+  uint8_t *d_u = pBuffer->m_u_buffer_ptr;
+  uint8_t *d_v = pBuffer->m_v_buffer_ptr;
+  for (int y = 0; y < h/4; y++)
+  {
+    uint8_t *s_uv = procOut->UVbuff + (y * stride);
+    for (int x = 0; x < w/2; x++)
+    {
+      *d_u++ = *s_uv++;
+      *d_v++ = *s_uv++;
+    }
+    s_uv = procOut->UVbuff + (y * stride);
+    for (int x = 0; x < w/2; x++)
+    {
+      *d_u++ = *s_uv++;
+      *d_v++ = *s_uv++;
+    }
+  }
+
+  pBuffer->m_interlace = false;
+}
+
+void CMPCOutputThread::CopyOutAsNV12(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride)
+{
+  if (w == stride)
+  {
+    int bytes = w * h;
+    // copy y
+    memcpy(pBuffer->m_y_buffer_ptr, procOut->Ybuff, bytes);
+    // copy uv
+    memcpy(pBuffer->m_uv_buffer_ptr, procOut->UVbuff, bytes/2 );
+  }
+  else
+  {
+    // copy y
+    uint8_t *s = procOut->Ybuff;
+    uint8_t *d = pBuffer->m_y_buffer_ptr;
+    for (int y = 0; y < h; y++, s += stride, d += w)
+      memcpy(d, s, w);
+    // copy uv
+    s = procOut->UVbuff;
+    d = pBuffer->m_uv_buffer_ptr;
+    for (int y = 0; y < h/2; y++, s += stride, d += w)
+      memcpy(d, s, w);
+  }
+}
+
+void CMPCOutputThread::CopyOutAsNV12DeInterlace(CPictureBuffer *pBuffer, BCM::BC_DTS_PROC_OUT *procOut, int w, int h, int stride)
+{
+  // do simple line doubling de-interlacing.
+  // copy luma
+  uint8_t *s_y = procOut->Ybuff;
+  uint8_t *d_y = pBuffer->m_y_buffer_ptr;
+  for (int y = 0; y < h/2; y++, s_y += stride)
+  {
+    memcpy(d_y, s_y, w);
+    d_y += w;
+    memcpy(d_y, s_y, w);
+    d_y += w;
+  }
+  //copy chroma
+  uint8_t *s_uv = procOut->UVbuff;
+  uint8_t *d_uv = pBuffer->m_uv_buffer_ptr;
+  for (int y = 0; y < h/4; y++, s_uv += stride) {
+    memcpy(d_uv, s_uv, w);
+    d_uv += w;
+    memcpy(d_uv, s_uv, w);
+    d_uv += w;
+  }
+  pBuffer->m_interlace = false;
+}
+
+void CMPCOutputThread::CheckUpperLeftGreenPixelHack(CPictureBuffer *pBuffer)
+{
+  // crystalhd driver sends internal info in 1st pixel location, then restores
+  // original pixel value but sometimes, the info is broked and the
+  // driver cannot do the restore and zeros the pixel. This is wrong for
+  // yuv color space, uv values should be set to 128 otherwise we get a
+  // bright green pixel in upper left.
+  // We fix this by replicating the 2nd pixel to the 1st.
+  switch(pBuffer->m_format)
+  {
+    default:
+    case RENDER_FMT_YUV420P:
+    {
+      uint8_t *d_y = pBuffer->m_y_buffer_ptr;
+      uint8_t *d_u = pBuffer->m_u_buffer_ptr;
+      uint8_t *d_v = pBuffer->m_v_buffer_ptr;
+      d_y[0] = d_y[1];
+      d_u[0] = d_u[1];
+      d_v[0] = d_v[1];
+    }
+    break;
+
+    case RENDER_FMT_NV12:
+    {
+      uint8_t  *d_y  = pBuffer->m_y_buffer_ptr;
+      uint16_t *d_uv = (uint16_t*)pBuffer->m_uv_buffer_ptr;
+      d_y[0] = d_y[1];
+      d_uv[0] = d_uv[1];
+    }
+    break;
+
+    case RENDER_FMT_YUYV422:
+    {
+      uint32_t *d_yuyv = (uint32_t*)pBuffer->m_y_buffer_ptr;
+      d_yuyv[0] = d_yuyv[1];
+    }
+    break;
+  }
+}
+
+bool CMPCOutputThread::GetDecoderOutput(void)
+{
+  BCM::BC_STATUS ret;
+  BCM::BC_DTS_PROC_OUT procOut;
+  CPictureBuffer *pBuffer = NULL;
+  bool got_picture = false;
+
+  // Setup output struct
+  memset(&procOut, 0, sizeof(BCM::BC_DTS_PROC_OUT));
+
+  // Fetch data from the decoder
+  ret = m_dll->DtsProcOutputNoCopy(m_device, m_timeout, &procOut);
+
+  switch (ret)
+  {
+    case BCM::BC_STS_SUCCESS:
+      if (m_format_valid && (procOut.PoutFlags & BCM::BC_POUT_FLAGS_PIB_VALID))
+      {
+        if (procOut.PicInfo.timeStamp && 
+          m_timestamp != procOut.PicInfo.timeStamp &&
+          m_width == (int)procOut.PicInfo.width && 
+          m_height == (int)procOut.PicInfo.height)
+        {
+          m_timestamp = procOut.PicInfo.timeStamp;
+          m_PictureNumber = procOut.PicInfo.picture_number;
+
+          if (m_framerate_tracking)
+            DoFrameRateTracking((double)m_timestamp / 1000.0);
+
+          // do not let FreeList to get greater than 10
+          if (m_FreeList.Count() > 10)
+            delete m_FreeList.Pop();
+
+          // Get next output buffer from the free list
+          pBuffer = m_FreeList.Pop();
+          if (!pBuffer)
+          {
+            // No free pre-allocated buffers so make one
+            if (m_output_YV12)
+            {
+              // output YV12, nouveau driver has slow NV12, YUY2 capability.
+              pBuffer = new CPictureBuffer(RENDER_FMT_YUV420P, m_width, m_height);
+            }
+            else
+            {
+              if (m_color_space == BCM::MODE422_YUY2)
+                pBuffer = new CPictureBuffer(RENDER_FMT_YUYV422, m_width, m_height);
+              else
+                pBuffer = new CPictureBuffer(RENDER_FMT_NV12, m_width, m_height);
+            }
+
+            CLog::Log(LOGDEBUG, "%s: Added a new Buffer, ReadyListCount: %d", __MODULE_NAME__, m_ReadyList.Count());
+            while (!m_bStop && m_ReadyList.Count() > 10)
+              Sleep(1);
+          }
+
+          pBuffer->m_width = m_width;
+          pBuffer->m_height = m_height;
+          pBuffer->m_field = CRYSTALHD_FIELD_FULL;
+          pBuffer->m_interlace = m_interlace > 0 ? true : false;
+          pBuffer->m_framerate = m_framerate;
+          pBuffer->m_timestamp = m_timestamp;
+          pBuffer->m_color_space = m_color_space;
+          pBuffer->m_color_range = m_color_range;
+          pBuffer->m_color_matrix = m_color_matrix;
+          pBuffer->m_PictureNumber = m_PictureNumber;
+
+          int w = m_width;
+          int h = m_height;
+          // frame that are not equal in width to 720, 1280 or 1920
+          // need to be copied by a quantized stride (possible lib/driver bug) so force it.
+          int stride = m_width;
+          if (!m_has_bcm70015)
+          {
+            // bcm70012 uses quantized strides
+            if (w <= 720)
+              stride = 720;
+            else if (w <= 1280)
+              stride = 1280;
+            else
+              stride = 1920;
+          }
+
+          if (pBuffer->m_color_space == BCM::MODE420)
+          {
+            switch(pBuffer->m_format)
+            {
+              case RENDER_FMT_NV12:
+                if (pBuffer->m_interlace)
+                  CopyOutAsNV12DeInterlace(pBuffer, &procOut, w, h, stride);
+                else
+                  CopyOutAsNV12(pBuffer, &procOut, w, h, stride);
+              break;
+              case RENDER_FMT_YUV420P:
+                if (pBuffer->m_interlace)
+                  CopyOutAsYV12DeInterlace(pBuffer, &procOut, w, h, stride);
+                else
+                  CopyOutAsYV12(pBuffer, &procOut, w, h, stride);
+              break;
+              default:
+              break;
+            }
+          }
+          else
+          {
+            switch(pBuffer->m_format)
+            {
+              case RENDER_FMT_YUYV422:
+                if (pBuffer->m_interlace)
+                {
+                  // do simple line doubling de-interlacing.
+                  // copy luma
+                  int yuy2_w = w * 2;
+                  int yuy2_stride = stride*2;
+                  uint8_t *s_y = procOut.Ybuff;
+                  uint8_t *d_y = pBuffer->m_y_buffer_ptr;
+                  for (int y = 0; y < h/2; y++, s_y += yuy2_stride)
+                  {
+                    memcpy(d_y, s_y, yuy2_w);
+                    d_y += yuy2_w;
+                    memcpy(d_y, s_y, yuy2_w);
+                    d_y += yuy2_w;
+                  }
+                  pBuffer->m_interlace = false;
+                }
+                else
+                {
+                  memcpy(pBuffer->m_y_buffer_ptr,  procOut.Ybuff, pBuffer->m_y_buffer_size);
+                }
+              break;
+              case RENDER_FMT_YUV420P:
+                // TODO: deinterlace for yuy2 -> yv12, icky
+                {
+                  // Perform the color space conversion.
+                  uint8_t* src[] =       { procOut.Ybuff, NULL, NULL, NULL };
+                  int      srcStride[] = { stride*2, 0, 0, 0 };
+                  uint8_t* dst[] =       { pBuffer->m_y_buffer_ptr, pBuffer->m_u_buffer_ptr, pBuffer->m_v_buffer_ptr, NULL };
+                  int      dstStride[] = { pBuffer->m_width, pBuffer->m_width/2, pBuffer->m_width/2, 0 };
+
+                  m_sw_scale_ctx = sws_getCachedContext(m_sw_scale_ctx,
+                    pBuffer->m_width, pBuffer->m_height, PIX_FMT_YUYV422,
+                    pBuffer->m_width, pBuffer->m_height, PIX_FMT_YUV420P,
+                    SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
+                  sws_scale(m_sw_scale_ctx, src, srcStride, 0, pBuffer->m_height, dst, dstStride);
+                }
+              break;
+              default:
+              break;
+            }
+          }
+
+          CheckUpperLeftGreenPixelHack(pBuffer);
+          m_ReadyList.Push(pBuffer);
+          m_ready_event.Set();
+          got_picture = true;
+        }
+        else
+        {
+          if (m_PictureNumber != procOut.PicInfo.picture_number)
+            CLog::Log(LOGDEBUG, "%s: No timestamp detected: %" PRIu64, __MODULE_NAME__, procOut.PicInfo.timeStamp);
+          m_PictureNumber = procOut.PicInfo.picture_number;
+        }
+      }
+
+      m_dll->DtsReleaseOutputBuffs(m_device, NULL, FALSE);
+    break;
+
+    case BCM::BC_STS_FMT_CHANGE:
+      CLog::Log(LOGDEBUG, "%s: Format Change Detected. Flags: 0x%08x", __MODULE_NAME__, procOut.PoutFlags);
+      if ((procOut.PoutFlags & BCM::BC_POUT_FLAGS_PIB_VALID) && (procOut.PoutFlags & BCM::BC_POUT_FLAGS_FMT_CHANGE))
+      {
+        PrintFormat(procOut.PicInfo);
+
+        if (procOut.PicInfo.height == 1088) {
+          procOut.PicInfo.height = 1080;
+        }
+        m_width = procOut.PicInfo.width;
+        m_height = procOut.PicInfo.height;
+        m_timestamp = DVD_NOPTS_VALUE;
+        m_color_space = procOut.b422Mode;
+        m_color_range = 0;
+        m_color_matrix = procOut.PicInfo.colour_primaries;
+        SetAspectRatio(&procOut.PicInfo);
+        SetFrameRate(procOut.PicInfo.frame_rate);
+        if (procOut.PicInfo.flags & VDEC_FLAG_INTERLACED_SRC)
+        {
+          m_interlace = true;
+        }
+        m_timeout = 2000;
+        m_format_valid = true;
+        m_ready_event.Set();
+      }
+    break;
+
+    case BCM::BC_STS_DEC_NOT_OPEN:
+    break;
+
+    case BCM::BC_STS_DEC_NOT_STARTED:
+    break;
+
+    case BCM::BC_STS_IO_USER_ABORT:
+    break;
+
+    case BCM::BC_STS_NO_DATA:
+    break;
+
+    case BCM::BC_STS_TIMEOUT:
+    break;
+
+    default:
+      if (ret > 26)
+        CLog::Log(LOGDEBUG, "%s: DtsProcOutput returned %d.", __MODULE_NAME__, ret);
+      else
+        CLog::Log(LOGDEBUG, "%s: DtsProcOutput returned %s.", __MODULE_NAME__, g_DtsStatusText[ret]);
+    break;
+  }
+  
+  return got_picture;
+}
+
+void CMPCOutputThread::Process(void)
+{
+  BCM::BC_STATUS ret;
+  BCM::BC_DTS_STATUS decoder_status;
+
+  m_PictureNumber = 0;
+
+  CLog::Log(LOGDEBUG, "%s: Output Thread Started...", __MODULE_NAME__);
+
+  // wait for decoder startup, calls into DtsProcOutputXXCopy will
+  // return immediately until decoder starts getting input packets. 
+  while (!m_bStop)
+  {
+    memset(&decoder_status, 0, sizeof(decoder_status));
+    ret = m_dll->DtsGetDriverStatus(m_device, &decoder_status);
+    if (ret == BCM::BC_STS_SUCCESS && decoder_status.ReadyListCount)
+    {
+      GetDecoderOutput();
+      break;
+    }
+    Sleep(10);
+  }
+
+  // decoder is primed so now calls in DtsProcOutputXXCopy will block
+  while (!m_bStop)
+  {
+    memset(&decoder_status, 0, sizeof(decoder_status));
+    ret = m_dll->DtsGetDriverStatus(m_device, &decoder_status);
+    if (ret == BCM::BC_STS_SUCCESS && decoder_status.ReadyListCount != 0)
+      GetDecoderOutput();
+    else
+      Sleep(1);
+
+#ifdef USE_CHD_SINGLE_THREADED_API
+    while (!m_bStop)
+    {
+      ret = m_dll->DtsGetDriverStatus(m_device, &decoder_status);
+      if (ret == BCM::BC_STS_SUCCESS && decoder_status.ReadyListCount != 0)
+      {
+        double pts = (double)decoder_status.NextTimeStamp / 1000.0;
+        fprintf(stdout, "cpbEmptySize(%d), NextTimeStamp(%f)\n", decoder_status.cpbEmptySize, pts);
+        break;
+      }
+      Sleep(10);
+    }
+#endif
+  }
+  CLog::Log(LOGDEBUG, "%s: Output Thread Stopped...", __MODULE_NAME__);
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////
+#if defined(TARGET_DARWIN)
+#pragma mark -
+#endif
+CCrystalHD* CCrystalHD::m_pInstance = NULL;
+
+CCrystalHD::CCrystalHD() :
+  m_device(NULL),
+  m_device_preset(false),
+  m_new_lib(false),
+  m_decoder_open(false),
+  m_has_bcm70015(false),
+  m_color_space(BCM::MODE420),
+  m_drop_state(false),
+  m_skip_state(false),
+  m_timeout(0),
+  m_wait_timeout(0),
+  m_field(0),
+  m_width(0),
+  m_height(0),
+  m_reset(0),
+  m_last_pict_num(0),
+  m_last_demuxer_pts(0.0),
+  m_last_decoder_pts(0.0),
+  m_pOutputThread(NULL),
+  m_sps_pps_size(0),
+  m_convert_bitstream(false)
+{
+#if (HAVE_LIBCRYSTALHD == 2)
+  memset(&m_bc_info_crystal, 0, sizeof(m_bc_info_crystal));
+#endif
+
+  memset(&m_chd_params, 0, sizeof(m_chd_params));
+  memset(&m_sps_pps_context, 0, sizeof(m_sps_pps_context));
+
+  m_dll = new DllLibCrystalHD;
+#ifdef TARGET_WINDOWS
+  std::string  strDll;
+  if(CWIN32Util::GetCrystalHDLibraryPath(strDll) && m_dll->SetFile(strDll) && m_dll->Load() && m_dll->IsLoaded() )
+#else
+  if (m_dll->Load() && m_dll->IsLoaded() )
+#endif
+  {
+#if (HAVE_LIBCRYSTALHD == 2)
+    m_new_lib = m_dll->LoadNewLibFunctions();
+#endif
+
+    OpenDevice();
+    
+#if (HAVE_LIBCRYSTALHD == 2)
+    if (m_device && m_new_lib)
+    {
+      m_dll->DtsCrystalHDVersion(m_device, (BCM::PBC_INFO_CRYSTAL)&m_bc_info_crystal);
+      m_has_bcm70015 = (m_bc_info_crystal.device == 1);
+      // bcm70012 can do nv12 (420), yuy2 (422) and uyvy (422)
+      // bcm70015 can do only yuy2 (422)
+      if (m_has_bcm70015)
+        m_color_space = BCM::OUTPUT_MODE422_YUY2;
+    }
+#endif
+  }
+
+  // delete dll if device open fails, minimizes ram footprint
+  if (!m_device)
+  {
+    delete m_dll;
+    m_dll = NULL;
+    CLog::Log(LOGDEBUG, "%s: broadcom crystal hd not found", __MODULE_NAME__);
+  }
+  else
+  {
+    // we know there's a device present now, close the device until doing playback
+    CloseDevice();
+  }
+}
+
+
+CCrystalHD::~CCrystalHD()
+{
+  if (m_decoder_open)
+    CloseDecoder();
+
+  if (m_device)
+    CloseDevice();
+
+  if (m_dll)
+    delete m_dll;
+}
+
+
+bool CCrystalHD::DevicePresent(void)
+{
+  return m_device_preset;
+}
+
+void CCrystalHD::RemoveInstance(void)
+{
+  if (m_pInstance)
+  {
+    delete m_pInstance;
+    m_pInstance = NULL;
+  }
+}
+
+CCrystalHD* CCrystalHD::GetInstance(void)
+{
+  if (!m_pInstance)
+  {
+    m_pInstance = new CCrystalHD();
+  }
+  return m_pInstance;
+}
+
+void CCrystalHD::OpenDevice()
+{
+  uint32_t mode = BCM::DTS_PLAYBACK_MODE          |
+                  BCM::DTS_LOAD_FILE_PLAY_FW      |
+#ifdef USE_CHD_SINGLE_THREADED_API
+                  BCM::DTS_SINGLE_THREADED_MODE   |
+#endif
+                  BCM::DTS_SKIP_TX_CHK_CPB        |
+                  BCM::DTS_PLAYBACK_DROP_RPT_MODE |
+                  DTS_DFLT_RESOLUTION(BCM::vdecRESOLUTION_720p23_976);
+
+  BCM::BC_STATUS res= m_dll->DtsDeviceOpen(&m_device, mode);
+  if (res != BCM::BC_STS_SUCCESS)
+  {
+    m_device = NULL;
+    if( res == BCM::BC_STS_DEC_EXIST_OPEN )
+      CLog::Log(LOGDEBUG, "%s: device owned by another application", __MODULE_NAME__);
+    else
+      CLog::Log(LOGDEBUG, "%s: device open failed , returning(0x%x)", __MODULE_NAME__, res);
+    m_device_preset = false;
+  }
+  else
+  {
+    #if (HAVE_LIBCRYSTALHD == 2)
+      if (m_new_lib)
+        CLog::Log(LOGDEBUG, "%s(new API): device opened", __MODULE_NAME__);
+      else
+        CLog::Log(LOGDEBUG, "%s(old API): device opened", __MODULE_NAME__);
+    #else
+      CLog::Log(LOGDEBUG, "%s: device opened", __MODULE_NAME__);
+    #endif
+    m_device_preset = true;
+  }
+}
+
+void CCrystalHD::CloseDevice()
+{
+  if (m_device)
+  {
+    m_dll->DtsDeviceClose(m_device);
+    m_device = NULL;
+    CLog::Log(LOGDEBUG, "%s: device closed", __MODULE_NAME__);
+  }
+}
+
+bool CCrystalHD::OpenDecoder(CRYSTALHD_CODEC_TYPE codec_type, CDVDStreamInfo &hints)
+{
+  BCM::BC_STATUS res;
+  uint32_t StreamType;
+#if (HAVE_LIBCRYSTALHD == 2)
+  BCM::BC_MEDIA_SUBTYPE Subtype;
+#endif
+
+  if (!m_device_preset)
+    return false;
+
+  if (m_decoder_open)
+    CloseDecoder();
+    
+  OpenDevice();
+  if (!m_device)
+    return false;
+
+#if (HAVE_LIBCRYSTALHD == 2) && defined(TARGET_WINDOWS)
+  // Drivers prior to 3.6.9.32 don't have proper support for CRYSTALHD_CODEC_ID_AVC1
+  // The internal version numbers are different for some reason...
+  if (   (m_bc_info_crystal.dilVersion.dilRelease < 3)
+      || (m_bc_info_crystal.dilVersion.dilRelease == 3 && m_bc_info_crystal.dilVersion.dilMajor < 22)
+      || (m_bc_info_crystal.drvVersion.drvRelease < 3)
+      || (m_bc_info_crystal.drvVersion.drvRelease == 3 && m_bc_info_crystal.drvVersion.drvMajor < 7) )
+  {
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Warning, "CrystalHD", g_localizeStrings.Get(2101));
+    CLog::Log(LOGWARNING, "CrystalHD drivers too old, please upgrade to 3.6.9 or later. Make sure to uninstall the old version first or the upgrade won't work.");
+
+    if (codec_type == CRYSTALHD_CODEC_ID_AVC1)
+      return false;
+  }
+#endif
+
+  uint32_t videoAlg = 0;
+  switch (codec_type)
+  {
+    case CRYSTALHD_CODEC_ID_VC1:
+      videoAlg = BCM::BC_VID_ALGO_VC1;
+      StreamType = BCM::BC_STREAM_TYPE_ES;
+      m_convert_bitstream = false;
+    break;
+    case CRYSTALHD_CODEC_ID_WVC1:
+      videoAlg = BCM::BC_VID_ALGO_VC1MP;
+      StreamType = BCM::BC_STREAM_TYPE_ES;
+      m_convert_bitstream = false;
+    break;
+    case CRYSTALHD_CODEC_ID_WMV3:
+      if (!m_has_bcm70015)
+        return false;
+      videoAlg = BCM::BC_VID_ALGO_VC1MP;
+      StreamType = BCM::BC_STREAM_TYPE_ES;
+      m_convert_bitstream = false;
+    break;
+    case CRYSTALHD_CODEC_ID_H264:
+      videoAlg = BCM::BC_VID_ALGO_H264;
+      StreamType = BCM::BC_STREAM_TYPE_ES;
+      m_convert_bitstream = false;
+    break;
+    case CRYSTALHD_CODEC_ID_AVC1:
+      videoAlg = BCM::BC_VID_ALGO_H264;
+      StreamType = BCM::BC_STREAM_TYPE_ES;
+      if (!m_new_lib)
+        m_convert_bitstream = bitstream_convert_init((uint8_t*)hints.extradata, hints.extrasize);
+      else
+        m_convert_bitstream = false;
+    break;
+    case CRYSTALHD_CODEC_ID_MPEG2:
+      videoAlg = BCM::BC_VID_ALGO_MPEG2;
+      StreamType = BCM::BC_STREAM_TYPE_ES;
+      m_convert_bitstream = false;
+    break;
+    //BC_VID_ALGO_DIVX:
+    //BC_VID_ALGO_VC1MP:
+    default:
+      return false;
+    break;
+  }
+  
+#if (HAVE_LIBCRYSTALHD == 2)
+  uint8_t *pMetaData = NULL;
+  uint32_t metaDataSz = 0;
+  uint32_t startCodeSz = 4;
+  m_chd_params.sps_pps_buf = NULL;
+  switch (codec_type)
+  {
+    case CRYSTALHD_CODEC_ID_VC1:
+      Subtype = BCM::BC_MSUBTYPE_VC1;
+      pMetaData = (uint8_t*)hints.extradata;
+      metaDataSz = hints.extrasize;
+    break;
+    case CRYSTALHD_CODEC_ID_WVC1:
+      Subtype = BCM::BC_MSUBTYPE_WVC1;
+    break;
+    case CRYSTALHD_CODEC_ID_WMV3:
+      Subtype = BCM::BC_MSUBTYPE_WMV3;
+      pMetaData = (uint8_t*)hints.extradata;
+      metaDataSz = hints.extrasize;
+    break;
+    case CRYSTALHD_CODEC_ID_H264:
+      Subtype = BCM::BC_MSUBTYPE_H264;
+      pMetaData = (uint8_t*)hints.extradata;
+      metaDataSz = hints.extrasize;
+    break;
+    case CRYSTALHD_CODEC_ID_AVC1:
+      Subtype = BCM::BC_MSUBTYPE_AVC1;
+      m_chd_params.sps_pps_buf = (uint8_t*)malloc(1000);
+			if (!extract_sps_pps_from_avcc(hints.extrasize, hints.extradata))
+      {
+        free(m_chd_params.sps_pps_buf);
+        m_chd_params.sps_pps_buf = NULL;
+			}
+      else
+      {
+        pMetaData = m_chd_params.sps_pps_buf;
+        metaDataSz = m_chd_params.sps_pps_size;
+        startCodeSz = m_chd_params.nal_size_bytes;
+      }
+    break;
+    case CRYSTALHD_CODEC_ID_MPEG2:
+      Subtype = BCM::BC_MSUBTYPE_MPEG2VIDEO;
+      pMetaData = (uint8_t*)hints.extradata;
+      metaDataSz = hints.extrasize;
+    break;
+    //BC_VID_ALGO_DIVX:
+    //BC_VID_ALGO_VC1MP:
+  }
+#endif
+
+  do
+  {
+#if (HAVE_LIBCRYSTALHD == 2)
+    if (m_new_lib)
+    {
+      BCM::BC_INPUT_FORMAT bcm_input_format;
+      memset(&bcm_input_format, 0, sizeof(BCM::BC_INPUT_FORMAT));
+
+      bcm_input_format.FGTEnable = FALSE;
+      bcm_input_format.Progressive = TRUE;
+      bcm_input_format.OptFlags = 0x80000000 | BCM::vdecFrameRate23_97;
+      #ifdef USE_CHD_SINGLE_THREADED_API
+        bcm_input_format.OptFlags |= 0x80;
+      #endif
+      
+      bcm_input_format.width = hints.width;
+      bcm_input_format.height = hints.height;
+      bcm_input_format.mSubtype = Subtype;
+      bcm_input_format.pMetaData = pMetaData;
+      bcm_input_format.metaDataSz = metaDataSz;
+      bcm_input_format.startCodeSz = startCodeSz;
+
+      res = m_dll->DtsSetInputFormat(m_device, &bcm_input_format);
+      if (res != BCM::BC_STS_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s: set input format failed", __MODULE_NAME__);
+        break;
+      }
+
+      res = m_dll->DtsOpenDecoder(m_device, StreamType);
+      if (res != BCM::BC_STS_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s: open decoder failed", __MODULE_NAME__);
+        break;
+      }
+
+      if (m_has_bcm70015)
+        res = m_dll->DtsSetColorSpace(m_device, BCM::OUTPUT_MODE422_YUY2); 
+      else
+        res = m_dll->DtsSetColorSpace(m_device, BCM::OUTPUT_MODE420); 
+      if (res != BCM::BC_STS_SUCCESS)
+      { 
+        CLog::Log(LOGERROR, "%s: set color space failed", __MODULE_NAME__); 
+        break; 
+      }
+    }
+    else
+#endif
+    {
+      res = m_dll->DtsOpenDecoder(m_device, StreamType);
+      if (res != BCM::BC_STS_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s: open decoder failed", __MODULE_NAME__);
+        break;
+      }
+
+      uint32_t OptFlags = 0x80000000 | BCM::vdecFrameRate23_97;
+      res = m_dll->DtsSetVideoParams(m_device, videoAlg, FALSE, FALSE, TRUE, OptFlags);
+      if (res != BCM::BC_STS_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s: set video params failed", __MODULE_NAME__);
+        break;
+      }
+    }
+    
+    res = m_dll->DtsStartDecoder(m_device);
+    if (res != BCM::BC_STS_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s: start decoder failed", __MODULE_NAME__);
+      break;
+    }
+
+    res = m_dll->DtsStartCapture(m_device);
+    if (res != BCM::BC_STS_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s: start capture failed", __MODULE_NAME__);
+      break;
+    }
+
+    m_pOutputThread = new CMPCOutputThread(m_device, m_dll, m_has_bcm70015);
+    m_pOutputThread->Create();
+
+    m_drop_state = false;
+    m_skip_state = false;
+    m_decoder_open = true;
+    // set output timeout to 1ms during startup,
+    // this will get reset once we get a picture back.
+    // the effect is to speed feeding demux packets during startup.
+    m_wait_timeout = 1;
+    m_reset = 0;
+    m_last_pict_num = 0;
+    m_last_demuxer_pts = DVD_NOPTS_VALUE;
+    m_last_decoder_pts = DVD_NOPTS_VALUE;
+  } while(false);
+
+  return m_decoder_open;
+}
+
+void CCrystalHD::CloseDecoder(void)
+{
+  if (m_pOutputThread)
+  {
+    while(m_BusyList.Count())
+      m_pOutputThread->FreeListPush( m_BusyList.Pop() );
+
+    m_pOutputThread->StopThread();
+    delete m_pOutputThread;
+    m_pOutputThread = NULL;
+  }
+
+  if (m_convert_bitstream)
+  {
+    if (m_sps_pps_context.sps_pps_data)
+    {
+      free(m_sps_pps_context.sps_pps_data);
+      m_sps_pps_context.sps_pps_data = NULL;
+    }
+  }
+#if (HAVE_LIBCRYSTALHD == 2)
+	if (m_chd_params.sps_pps_buf)
+  {
+		free(m_chd_params.sps_pps_buf);
+		m_chd_params.sps_pps_buf = NULL;
+	}
+#endif
+
+  if (m_decoder_open)
+  {
+    // DtsFlushRxCapture must release internal queues when
+    // calling DtsStopDecoder/DtsCloseDecoder or the next
+    // DtsStartCapture will fail. This is a driver/lib bug
+    // with new chd driver. The existing driver ignores the
+    // bDiscardOnly arg.
+    if (!m_has_bcm70015)
+      m_dll->DtsFlushRxCapture(m_device, false);
+    m_dll->DtsStopDecoder(m_device);
+    m_dll->DtsCloseDecoder(m_device);
+    m_decoder_open = false;
+  }
+  
+  CloseDevice();
+}
+
+void CCrystalHD::Reset(void)
+{
+  if (!m_has_bcm70015)
+  {
+    // Calling for non-error flush, Flushes all the decoder
+    //  buffers, input, decoded and to be decoded. 
+    m_reset = 10;
+    m_wait_timeout = 1;
+    m_dll->DtsFlushInput(m_device, 2);
+  }
+
+  while (m_BusyList.Count())
+    m_pOutputThread->FreeListPush( m_BusyList.Pop() );
+
+  while (m_pOutputThread->GetReadyCount())
+  {
+    ::Sleep(1);
+    m_pOutputThread->FreeListPush( m_pOutputThread->ReadyListPop() );
+  }
+}
+
+bool CCrystalHD::AddInput(unsigned char *pData, size_t size, double dts, double pts)
+{
+  if (pData)
+  {
+    BCM::BC_STATUS ret;
+    uint64_t int_pts = pts * 1000;
+    int demuxer_bytes = size;
+    uint8_t *demuxer_content = pData;
+    bool free_demuxer_content  = false;
+
+    if (m_convert_bitstream)
+    {
+      // convert demuxer packet from bitstream (AVC1) to bytestream (AnnexB)
+      int bytestream_size = 0;
+      uint8_t *bytestream_buff = NULL;
+
+      bitstream_convert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size);
+      if (bytestream_buff && (bytestream_size > 0))
+      {
+        if (bytestream_buff != demuxer_content)
+          free_demuxer_content = true;
+        demuxer_bytes = bytestream_size;
+        demuxer_content = bytestream_buff;
+      }
+    }
+
+    do
+    {
+      ret = m_dll->DtsProcInput(m_device, demuxer_content, demuxer_bytes, int_pts, 0);
+      if (ret == BCM::BC_STS_SUCCESS)
+      {
+        m_last_demuxer_pts = pts;
+      }
+      else if (ret == BCM::BC_STS_BUSY)
+      {
+        CLog::Log(LOGDEBUG, "%s: DtsProcInput returned BC_STS_BUSY", __MODULE_NAME__);
+        ::Sleep(1); // Buffer is full, sleep it empty
+      }
+    } while (ret != BCM::BC_STS_SUCCESS);
+
+    if (free_demuxer_content)
+      free(demuxer_content);
+
+    if (!m_has_bcm70015)
+    {
+      if (m_reset)
+      {
+        m_reset--;
+        if (!m_skip_state)
+        {
+          m_skip_state = true;
+          m_dll->DtsSetSkipPictureMode(m_device, 1);
+        }
+      }
+      else
+      {
+        if (m_skip_state)
+        {
+          m_skip_state = false;
+          m_dll->DtsSetSkipPictureMode(m_device, 0);
+        }
+      }
+    }
+
+    if (m_pOutputThread->GetReadyCount() < 1)
+      m_pOutputThread->WaitOutput(m_wait_timeout);
+  }
+
+  return true;
+}
+
+int CCrystalHD::GetReadyCount(void)
+{
+  if (m_pOutputThread)
+    return m_pOutputThread->GetReadyCount();
+  else
+    return 0;
+}
+
+void CCrystalHD::BusyListFlush(void)
+{
+  if (m_pOutputThread)
+  {
+    while ( m_BusyList.Count())
+      m_pOutputThread->FreeListPush( m_BusyList.Pop() );
+  }
+}
+
+bool CCrystalHD::GetPicture(DVDVideoPicture *pDvdVideoPicture)
+{
+  CPictureBuffer* pBuffer = m_pOutputThread->ReadyListPop();
+
+  if (!pBuffer)
+    return false;
+
+  // default both dts/pts to DVD_NOPTS_VALUE, if crystalhd drops a frame,
+  // we can't tell so we can not track dts through the decoder or with
+  // and external queue. pts will get set from m_timestamp.
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+
+  if (pBuffer->m_timestamp != 0)
+    pDvdVideoPicture->pts = (double)pBuffer->m_timestamp / 1000.0;
+
+  pDvdVideoPicture->iWidth = pBuffer->m_width;
+  pDvdVideoPicture->iHeight = pBuffer->m_height;
+  pDvdVideoPicture->iDisplayWidth = pBuffer->m_width;
+  pDvdVideoPicture->iDisplayHeight = pBuffer->m_height;
+
+  switch(pBuffer->m_format)
+  {
+    default:
+    case RENDER_FMT_NV12:
+      // Y plane
+      pDvdVideoPicture->data[0] = (uint8_t*)pBuffer->m_y_buffer_ptr;
+      pDvdVideoPicture->iLineSize[0] = pBuffer->m_width;
+      // UV packed plane
+      pDvdVideoPicture->data[1] = (uint8_t*)pBuffer->m_uv_buffer_ptr;
+      pDvdVideoPicture->iLineSize[1] = pBuffer->m_width;
+      // unused
+      pDvdVideoPicture->data[2] = NULL;
+      pDvdVideoPicture->iLineSize[2] = 0;
+    break;
+    case RENDER_FMT_YUYV422:
+      // YUV packed plane
+      pDvdVideoPicture->data[0] = (uint8_t*)pBuffer->m_y_buffer_ptr;
+      pDvdVideoPicture->iLineSize[0] = pBuffer->m_width * 2;
+      // unused
+      pDvdVideoPicture->data[1] = NULL;
+      pDvdVideoPicture->iLineSize[1] = 0;
+      // unused
+      pDvdVideoPicture->data[2] = NULL;
+      pDvdVideoPicture->iLineSize[2] = 0;
+    break;
+    case RENDER_FMT_YUV420P:
+      // Y plane
+      pDvdVideoPicture->data[0] = (uint8_t*)pBuffer->m_y_buffer_ptr;
+      pDvdVideoPicture->iLineSize[0] = pBuffer->m_width;
+      // U plane
+      pDvdVideoPicture->data[1] = (uint8_t*)pBuffer->m_u_buffer_ptr;
+      pDvdVideoPicture->iLineSize[1] = pBuffer->m_width / 2;
+      // V plane
+      pDvdVideoPicture->data[2] = (uint8_t*)pBuffer->m_v_buffer_ptr;
+      pDvdVideoPicture->iLineSize[2] = pBuffer->m_width / 2;
+    break;
+  }
+
+  pDvdVideoPicture->iRepeatPicture = 0;
+  pDvdVideoPicture->iDuration = DVD_TIME_BASE / pBuffer->m_framerate;
+  m_wait_timeout = pDvdVideoPicture->iDuration/2000;
+  pDvdVideoPicture->color_range = pBuffer->m_color_range;
+  pDvdVideoPicture->color_matrix = pBuffer->m_color_matrix;
+  pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
+  pDvdVideoPicture->iFlags |= m_drop_state ? DVP_FLAG_DROPPED : 0;
+  pDvdVideoPicture->format = pBuffer->m_format;
+
+  m_last_pict_num = pBuffer->m_PictureNumber;
+  m_last_decoder_pts = pDvdVideoPicture->pts;
+
+  while( m_BusyList.Count())
+    m_pOutputThread->FreeListPush( m_BusyList.Pop() );
+
+  m_BusyList.Push(pBuffer);
+  return true;
+}
+
+void CCrystalHD::SetDropState(bool bDrop)
+{
+  if (m_drop_state != bDrop)
+  {
+    m_drop_state = bDrop;
+    
+    if (!m_has_bcm70015)
+    {
+      if (!m_reset)
+      {
+        if (m_drop_state)
+        {
+          if (!m_skip_state)
+          {
+            m_skip_state = true;
+            m_dll->DtsSetSkipPictureMode(m_device, 1);
+            Sleep(1);
+          }
+        }
+        else
+        {
+          if (m_skip_state)
+          {
+            m_skip_state = false;
+            m_dll->DtsSetSkipPictureMode(m_device, 0);
+            Sleep(1);
+          }
+        }
+      }
+    }
+  }
+  /*
+  CLog::Log(LOGDEBUG, "%s: m_drop_state(%d), GetFreeCount(%d), GetReadyCount(%d)", __MODULE_NAME__, 
+      m_drop_state, m_pOutputThread->GetFreeCount(), m_pOutputThread->GetReadyCount());
+  */
+}
+////////////////////////////////////////////////////////////////////////////////////////////
+bool CCrystalHD::extract_sps_pps_from_avcc(int extradata_size, void *extradata)
+{
+  // based on gstbcmdec.c (bcmdec_insert_sps_pps)
+  // which is Copyright(c) 2008 Broadcom Corporation.
+  // and Licensed LGPL 2.1
+
+  uint8_t *data = (uint8_t*)extradata;
+  uint32_t data_size = extradata_size;
+  int profile;
+  unsigned int nal_size;
+  unsigned int num_sps, num_pps;
+
+  m_chd_params.sps_pps_size = 0;
+
+  profile = (data[1] << 16) | (data[2] << 8) | data[3];
+  CLog::Log(LOGDEBUG, "%s: profile %06x", __MODULE_NAME__, profile);
+
+  m_chd_params.nal_size_bytes = (data[4] & 0x03) + 1;
+
+  CLog::Log(LOGDEBUG, "%s: nal size %d", __MODULE_NAME__, m_chd_params.nal_size_bytes);
+
+  num_sps = data[5] & 0x1f;
+  CLog::Log(LOGDEBUG, "%s: num sps %d", __MODULE_NAME__, num_sps);
+
+  data += 6;
+  data_size -= 6;
+
+  for (unsigned int i = 0; i < num_sps; i++)
+  {
+    if (data_size < 2)
+      return false;
+
+    nal_size = (data[0] << 8) | data[1];
+    data += 2;
+    data_size -= 2;
+
+    if (data_size < nal_size)
+			return false;
+
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size + 0] = 0;
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size + 1] = 0;
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size + 2] = 0;
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size + 3] = 1;
+
+    m_chd_params.sps_pps_size += 4;
+
+    memcpy(m_chd_params.sps_pps_buf + m_chd_params.sps_pps_size, data, nal_size);
+    m_chd_params.sps_pps_size += nal_size;
+
+    data += nal_size;
+    data_size -= nal_size;
+  }
+
+  if (data_size < 1)
+    return false;
+
+  num_pps = data[0];
+  data += 1;
+  data_size -= 1;
+
+  for (unsigned int i = 0; i < num_pps; i++)
+  {
+    if (data_size < 2)
+      return false;
+
+    nal_size = (data[0] << 8) | data[1];
+    data += 2;
+    data_size -= 2;
+
+    if (data_size < nal_size)
+      return false;
+
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size+0] = 0;
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size+1] = 0;
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size+2] = 0;
+    m_chd_params.sps_pps_buf[m_chd_params.sps_pps_size+3] = 1;
+
+    m_chd_params.sps_pps_size += 4;
+
+    memcpy(m_chd_params.sps_pps_buf + m_chd_params.sps_pps_size, data, nal_size);
+    m_chd_params.sps_pps_size += nal_size;
+
+    data += nal_size;
+    data_size -= nal_size;
+  }
+
+  CLog::Log(LOGDEBUG, "%s: data size at end = %d ", __MODULE_NAME__, data_size);
+
+  return true;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////////////
+bool CCrystalHD::bitstream_convert_init(void *in_extradata, int in_extrasize)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  m_sps_pps_size = 0;
+  m_sps_pps_context.sps_pps_data = NULL;
+  
+  // nothing to filter
+  if (!in_extradata || in_extrasize < 6)
+    return false;
+
+  uint16_t unit_size;
+  uint32_t total_size = 0;
+  uint8_t *out = NULL, unit_nb, sps_done = 0;
+  const uint8_t *extradata = (uint8_t*)in_extradata + 4;
+  static const uint8_t nalu_header[4] = {0, 0, 0, 1};
+
+  // retrieve length coded size
+  m_sps_pps_context.length_size = (*extradata++ & 0x3) + 1;
+  if (m_sps_pps_context.length_size == 3)
+    return false;
+
+  // retrieve sps and pps unit(s)
+  unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
+  if (!unit_nb)
+  {
+    unit_nb = *extradata++;       // number of pps unit(s)
+    sps_done++;
+  }
+  while (unit_nb--)
+  {
+    unit_size = extradata[0] << 8 | extradata[1];
+    total_size += unit_size + 4;
+    if ( (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize) )
+    {
+      free(out);
+      return false;
+    }
+    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
+    if (new_out)
+    {
+      out = new_out;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
+      free(out);
+      return false;
+    }
+
+    memcpy(out + total_size - unit_size - 4, nalu_header, 4);
+    memcpy(out + total_size - unit_size, extradata + 2, unit_size);
+    extradata += 2 + unit_size;
+
+    if (!unit_nb && !sps_done++)
+      unit_nb = *extradata++;     // number of pps unit(s)
+  }
+
+  m_sps_pps_context.sps_pps_data = out;
+  m_sps_pps_context.size = total_size;
+  m_sps_pps_context.first_idr = 1;
+
+  return true;
+}
+
+bool CCrystalHD::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  uint8_t *buf = pData;
+  uint32_t buf_size = iSize;
+  uint8_t  unit_type;
+  int32_t  nal_size;
+  uint32_t cumul_size = 0;
+  const uint8_t *buf_end = buf + buf_size;
+
+  do
+  {
+    if (buf + m_sps_pps_context.length_size > buf_end)
+      goto fail;
+
+    if (m_sps_pps_context.length_size == 1)
+      nal_size = buf[0];
+    else if (m_sps_pps_context.length_size == 2)
+      nal_size = buf[0] << 8 | buf[1];
+    else
+      nal_size = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
+
+    buf += m_sps_pps_context.length_size;
+    unit_type = *buf & 0x1f;
+
+    if (buf + nal_size > buf_end || nal_size < 0)
+      goto fail;
+
+    // prepend only to the first type 5 NAL unit of an IDR picture
+    if (m_sps_pps_context.first_idr && unit_type == 5)
+    {
+      bitstream_alloc_and_copy(poutbuf, poutbuf_size,
+        m_sps_pps_context.sps_pps_data, m_sps_pps_context.size, buf, nal_size);
+      m_sps_pps_context.first_idr = 0;
+    }
+    else
+    {
+      bitstream_alloc_and_copy(poutbuf, poutbuf_size, NULL, 0, buf, nal_size);
+      if (!m_sps_pps_context.first_idr && unit_type == 1)
+          m_sps_pps_context.first_idr = 1;
+    }
+
+    buf += nal_size;
+    cumul_size += nal_size + m_sps_pps_context.length_size;
+  } while (cumul_size < buf_size);
+
+  return true;
+
+fail:
+  free(*poutbuf);
+  *poutbuf = NULL;
+  *poutbuf_size = 0;
+  return false;
+}
+
+void CCrystalHD::bitstream_alloc_and_copy(
+  uint8_t **poutbuf,      int *poutbuf_size,
+  const uint8_t *sps_pps, uint32_t sps_pps_size,
+  const uint8_t *in,      uint32_t in_size)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  #define CHD_WB32(p, d) { \
+    ((uint8_t*)(p))[3] = (d); \
+    ((uint8_t*)(p))[2] = (d) >> 8; \
+    ((uint8_t*)(p))[1] = (d) >> 16; \
+    ((uint8_t*)(p))[0] = (d) >> 24; }
+
+  uint32_t offset = *poutbuf_size;
+  uint8_t nal_header_size = offset ? 3 : 4;
+
+  *poutbuf_size += sps_pps_size + in_size + nal_header_size;
+  *poutbuf = (uint8_t*)realloc(*poutbuf, *poutbuf_size);
+  if (sps_pps)
+    memcpy(*poutbuf + offset, sps_pps, sps_pps_size);
+
+  memcpy(*poutbuf + sps_pps_size + nal_header_size + offset, in, in_size);
+  if (!offset)
+  {
+    CHD_WB32(*poutbuf + sps_pps_size, 1);
+  }
+  else
+  {
+    (*poutbuf + offset + sps_pps_size)[0] = 0;
+    (*poutbuf + offset + sps_pps_size)[1] = 0;
+    (*poutbuf + offset + sps_pps_size)[2] = 1;
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////
+void PrintFormat(BCM::BC_PIC_INFO_BLOCK &pib)
+{
+  CLog::Log(LOGDEBUG, "----------------------------------\n%s","");
+  CLog::Log(LOGDEBUG, "\tTimeStamp: %" PRIu64"\n", pib.timeStamp);
+  CLog::Log(LOGDEBUG, "\tPicture Number: %d\n", pib.picture_number);
+  CLog::Log(LOGDEBUG, "\tWidth: %d\n", pib.width);
+  CLog::Log(LOGDEBUG, "\tHeight: %d\n", pib.height);
+  CLog::Log(LOGDEBUG, "\tChroma: 0x%03x\n", pib.chroma_format);
+  CLog::Log(LOGDEBUG, "\tPulldown: %d\n", pib.pulldown);
+  CLog::Log(LOGDEBUG, "\tFlags: 0x%08x\n", pib.flags);
+  CLog::Log(LOGDEBUG, "\tFrame Rate/Res: %d\n", pib.frame_rate);
+  CLog::Log(LOGDEBUG, "\tAspect Ratio: %d\n", pib.aspect_ratio);
+  CLog::Log(LOGDEBUG, "\tColor Primaries: %d\n", pib.colour_primaries);
+  CLog::Log(LOGDEBUG, "\tMetaData: %d\n", pib.picture_meta_payload);
+  CLog::Log(LOGDEBUG, "\tSession Number: %d\n", pib.sess_num);
+  CLog::Log(LOGDEBUG, "\tTimeStamp: %d\n", pib.ycom);
+  CLog::Log(LOGDEBUG, "\tCustom Aspect: %d\n", pib.custom_aspect_ratio_width_height);
+  CLog::Log(LOGDEBUG, "\tFrames to Drop: %d\n", pib.n_drop);
+  CLog::Log(LOGDEBUG, "\tH264 Valid Fields: 0x%08x\n", pib.other.h264.valid);
+}
+
+#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h
new file mode 100644
index 0000000..451a107
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.h
@@ -0,0 +1,236 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(HAVE_LIBCRYSTALHD)
+
+#include <deque>
+
+#include "DVDVideoCodec.h"
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "threads/SingleLock.h"
+
+////////////////////////////////////////////////////////////////////////////////////////////
+template <class T>
+class CSyncPtrQueue
+{
+public:
+  CSyncPtrQueue() { }
+  virtual ~CSyncPtrQueue() { }
+  void Push(T* p)
+  {
+    CSingleLock lock(m_Lock);
+    m_Queue.push_back(p);
+  }
+
+  T* Pop()
+  {
+    T* p = NULL;
+    CSingleLock lock(m_Lock);
+    if (!m_Queue.empty())
+    {
+      p = m_Queue.front();
+      m_Queue.pop_front();
+    }
+    return p;
+  }
+  unsigned int Count(){return m_Queue.size();}
+protected:
+  std::deque<T*> m_Queue;
+  CCriticalSection m_Lock;
+};
+
+////////////////////////////////////////////////////////////////////////////////////////////
+class CPictureBuffer
+{
+public:
+  CPictureBuffer(ERenderFormat format, int width, int height);
+  virtual ~CPictureBuffer();
+
+  unsigned int  m_width;
+  unsigned int  m_height;
+  unsigned int  m_field;
+  bool          m_interlace;
+  double        m_framerate;
+  uint64_t      m_timestamp;
+  int           m_color_space;
+  unsigned int  m_color_range;
+  unsigned int  m_color_matrix;
+  uint64_t      m_PictureNumber;
+  ERenderFormat m_format;
+  unsigned char *m_y_buffer_ptr;
+  unsigned char *m_u_buffer_ptr;
+  unsigned char *m_v_buffer_ptr;
+  unsigned char *m_uv_buffer_ptr;
+  int           m_y_buffer_size;
+  int           m_u_buffer_size;
+  int           m_v_buffer_size;
+  int           m_uv_buffer_size;
+};
+
+
+////////////////////////////////////////////////////////////////////////////////////////////
+enum _CRYSTALHD_CODEC_TYPES
+{
+  CRYSTALHD_CODEC_ID_MPEG2 = 0,
+  CRYSTALHD_CODEC_ID_H264  = 1,
+  CRYSTALHD_CODEC_ID_AVC1  = 2,
+  CRYSTALHD_CODEC_ID_VC1   = 3,
+  CRYSTALHD_CODEC_ID_WMV3  = 4,
+  CRYSTALHD_CODEC_ID_WVC1  = 5,
+};
+
+typedef uint32_t CRYSTALHD_CODEC_TYPE;
+
+#if (HAVE_LIBCRYSTALHD == 2)
+
+  typedef struct _BC_INFO_CRYSTAL_ {
+	  uint8_t device;
+	  union {
+		  struct {
+			  uint32_t dilRelease:8;
+			  uint32_t dilMajor:8;
+			  uint32_t dilMinor:16;
+		  };
+		  uint32_t version;
+	  } dilVersion;
+
+	  union {
+		  struct {
+			  uint32_t drvRelease:4;
+			  uint32_t drvMajor:8;
+			  uint32_t drvMinor:12;
+			  uint32_t drvBuild:8;
+		  };
+		  uint32_t version;
+	  } drvVersion;
+
+	  union {
+		  struct {
+			  uint32_t fwRelease:4;
+			  uint32_t fwMajor:8;
+			  uint32_t fwMinor:12;
+			  uint32_t fwBuild:8;
+		  };
+		  uint32_t version;
+	  } fwVersion;
+
+	  uint32_t Reserved1; // For future expansion
+	  uint32_t Reserved2; // For future expansion
+  } BC_INFO_CRYSTAL, *PBC_INFO_CRYSTAL;
+
+#endif
+
+////////////////////////////////////////////////////////////////////////////////////////////
+
+#define CRYSTALHD_FIELD_FULL        0x00
+#define CRYSTALHD_FIELD_BOT         0x01
+#define CRYSTALHD_FIELD_TOP         0x02
+
+typedef struct CHD_CODEC_PARAMS {
+  uint8_t   *sps_pps_buf;
+  uint32_t  sps_pps_size;
+  uint8_t   nal_size_bytes;
+} CHD_CODEC_PARAMS;
+
+class DllLibCrystalHD;
+class CMPCInputThread;
+class CMPCOutputThread;
+
+class CCrystalHD
+{
+public:
+  virtual ~CCrystalHD();
+
+  static void RemoveInstance(void);
+  static CCrystalHD* GetInstance(void);
+
+  bool DevicePresent(void);
+
+  void OpenDevice();
+  void CloseDevice();
+
+  bool OpenDecoder(CRYSTALHD_CODEC_TYPE codec_type, CDVDStreamInfo &hints);
+  void CloseDecoder(void);
+  void Reset(void);
+
+  bool AddInput(unsigned char *pData, size_t size, double dts, double pts);
+
+  int  GetReadyCount(void);
+  void BusyListFlush(void);
+
+  bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  void SetDropState(bool bDrop);
+
+protected:
+
+  DllLibCrystalHD *m_dll;
+  void          *m_device;
+  bool          m_device_preset;
+  bool          m_new_lib;
+  bool          m_decoder_open;
+  bool          m_has_bcm70015;
+  int           m_color_space;
+  bool          m_drop_state;
+  bool          m_skip_state;
+  unsigned int  m_timeout;
+  unsigned int  m_wait_timeout;
+  unsigned int  m_field;
+  unsigned int  m_width;
+  unsigned int  m_height;
+  int           m_reset;
+  int           m_last_pict_num;
+  double        m_last_demuxer_pts;
+  double        m_last_decoder_pts;
+
+  CMPCOutputThread *m_pOutputThread;
+  CSyncPtrQueue<CPictureBuffer> m_BusyList;
+#if (HAVE_LIBCRYSTALHD == 2)
+  BC_INFO_CRYSTAL m_bc_info_crystal;
+#endif
+
+private:
+  CCrystalHD();
+  CCrystalHD(const CCrystalHD& other);
+  CCrystalHD& operator=(const CCrystalHD&);
+  static CCrystalHD *m_pInstance;
+
+  // bitstream to bytestream (Annex B) conversion support.
+  bool bitstream_convert_init(void *in_extradata, int in_extrasize);
+  bool bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
+  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
+    const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
+
+  typedef struct chd_bitstream_ctx {
+      uint8_t  length_size;
+      uint8_t  first_idr;
+      uint8_t *sps_pps_data;
+      uint32_t size;
+  } chd_bitstream_ctx;
+
+  uint32_t          m_sps_pps_size;
+  chd_bitstream_ctx m_sps_pps_context;
+  bool              m_convert_bitstream;
+
+  bool extract_sps_pps_from_avcc(int extradata_size, void *extradata);
+  CHD_CODEC_PARAMS  m_chd_params;
+};
+
+#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp
new file mode 100644
index 0000000..2368c62
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp
@@ -0,0 +1,204 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
+  #include "config.h"
+#elif defined(TARGET_WINDOWS)
+#include "system.h"
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
+#endif
+
+#if defined(HAVE_LIBCRYSTALHD)
+#include "DVDClock.h"
+#include "DVDStreamInfo.h"
+#include "DVDVideoCodecCrystalHD.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+
+#define __MODULE_NAME__ "DVDVideoCodecCrystalHD"
+
+CDVDVideoCodecCrystalHD::CDVDVideoCodecCrystalHD() :
+  m_Codec(NULL),
+  m_DropPictures(false),
+  m_Duration(0.0),
+  m_pFormatName(""),
+  m_CodecType(CRYSTALHD_CODEC_ID_MPEG2)
+{
+}
+
+CDVDVideoCodecCrystalHD::~CDVDVideoCodecCrystalHD()
+{
+  Dispose();
+}
+
+bool CDVDVideoCodecCrystalHD::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  if (CSettings::Get().GetBool("videoplayer.usechd") && !hints.software)
+  {
+    switch (hints.codec)
+    {
+      case AV_CODEC_ID_MPEG2VIDEO:
+        m_CodecType = CRYSTALHD_CODEC_ID_MPEG2;
+        m_pFormatName = "chd-mpeg2";
+      break;
+      case AV_CODEC_ID_H264:
+        switch(hints.profile)
+        {
+          case FF_PROFILE_H264_HIGH_10:
+          case FF_PROFILE_H264_HIGH_10_INTRA:
+          case FF_PROFILE_H264_HIGH_422:
+          case FF_PROFILE_H264_HIGH_422_INTRA:
+          case FF_PROFILE_H264_HIGH_444_PREDICTIVE:
+          case FF_PROFILE_H264_HIGH_444_INTRA:
+          case FF_PROFILE_H264_CAVLC_444:
+            CLog::Log(LOGNOTICE, "%s - unsupported h264 profile(%d)", __FUNCTION__, hints.profile);
+            return false;
+            break;
+        }
+        if (hints.extrasize < 7 || hints.extradata == NULL)
+        {
+          CLog::Log(LOGNOTICE, "%s - avcC atom too data small or missing", __FUNCTION__);
+          return false;
+        }
+        // valid avcC data (bitstream) always starts with the value 1 (version)
+        if ( *(char*)hints.extradata == 1 )
+          m_CodecType = CRYSTALHD_CODEC_ID_AVC1;
+        else
+          m_CodecType = CRYSTALHD_CODEC_ID_H264;
+
+        m_pFormatName = "chd-h264-osmc";
+      break;
+      case AV_CODEC_ID_VC1:
+        m_CodecType = CRYSTALHD_CODEC_ID_VC1;
+        m_pFormatName = "chd-vc1";
+      break;
+      case AV_CODEC_ID_WMV3:
+        m_CodecType = CRYSTALHD_CODEC_ID_WMV3;
+        m_pFormatName = "chd-wmv3";
+      break;
+      default:
+        return false;
+      break;
+    }
+
+    m_Codec = CCrystalHD::GetInstance();
+    if (!m_Codec)
+    {
+      CLog::Log(LOGERROR, "%s: Failed to open Broadcom Crystal HD Codec", __MODULE_NAME__);
+      return false;
+    }
+
+    if (m_Codec && !m_Codec->OpenDecoder(m_CodecType, hints))
+    {
+      CLog::Log(LOGERROR, "%s: Failed to open Broadcom Crystal HD Codec", __MODULE_NAME__);
+      return false;
+    }
+
+    // default duration to 23.976 fps, have to guess something.
+    m_Duration = (DVD_TIME_BASE / (24.0 * 1000.0/1001.0));
+    m_DropPictures = false;
+
+    CLog::Log(LOGINFO, "%s: Opened Broadcom Crystal HD Codec", __MODULE_NAME__);
+    return true;
+  }
+
+  return false;
+}
+
+void CDVDVideoCodecCrystalHD::Dispose(void)
+{
+  if (m_Codec)
+  {
+    m_Codec->CloseDecoder();
+    m_Codec = NULL;
+  }
+}
+
+int CDVDVideoCodecCrystalHD::Decode(uint8_t *pData, int iSize, double dts, double pts)
+{
+  if (!pData)
+  {
+    // if pData is nil, we are in dvdplayervideo's special loop
+    // where it checks for more picture frames, you must pass
+    // VC_BUFFER to get it to break out of this loop.
+    int ready_cnt = m_Codec->GetReadyCount();
+    if (ready_cnt == 1)
+      return VC_PICTURE | VC_BUFFER;
+    if (ready_cnt > 2)
+      return VC_PICTURE;
+    else
+      return VC_BUFFER;
+  }
+
+  // We are running a picture queue, picture frames are allocated
+  // in CrystalHD class if needed, then passed up. Need to return
+  // them back to CrystalHD class for re-queuing. This way we keep
+  // the memory alloc/free to a minimum and don't churn memory for
+  // each picture frame.
+  m_Codec->BusyListFlush();
+
+  if (pData)
+  {
+    // Handle Input, add demuxer packet to input queue, we must accept it or
+    // it will be discarded as DVDPlayerVideo has no concept of "try again".
+    if ( !m_Codec->AddInput(pData, iSize, dts, pts) )
+    {
+      // Deep crap error, this should never happen unless we run away pulling demuxer pkts.
+      CLog::Log(LOGDEBUG, "%s: m_pInputThread->AddInput full.", __MODULE_NAME__);
+      Sleep(10);
+    }
+  }
+
+  // if we have more than one frame ready, just return VC_PICTURE so 
+  // dvdplayervideo will loop and drain them before sending another demuxer packet.
+  if (m_Codec->GetReadyCount() > 2)
+    return VC_PICTURE;
+  
+  int rtn = 0;
+  if (m_Codec->GetReadyCount())
+    rtn = VC_PICTURE;
+
+  return rtn | VC_BUFFER;
+}
+
+void CDVDVideoCodecCrystalHD::Reset(void)
+{
+  m_Codec->Reset();
+}
+
+bool CDVDVideoCodecCrystalHD::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  bool  ret;
+  
+  ret = m_Codec->GetPicture(pDvdVideoPicture);
+  m_Duration = pDvdVideoPicture->iDuration;
+  return ret;
+}
+
+void CDVDVideoCodecCrystalHD::SetDropState(bool bDrop)
+{
+  m_DropPictures = bDrop;
+  m_Codec->SetDropState(m_DropPictures);
+}
+
+#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h
new file mode 100644
index 0000000..cc36c29
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h
@@ -0,0 +1,51 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_LIBCRYSTALHD)
+
+#include "CrystalHD.h"
+#include "DVDVideoCodec.h"
+
+class CDVDVideoCodecCrystalHD : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecCrystalHD();
+  virtual ~CDVDVideoCodecCrystalHD();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+protected:
+  CCrystalHD      *m_Codec;
+  bool            m_DropPictures;
+  double          m_Duration;
+  const char      *m_pFormatName;
+  CRYSTALHD_CODEC_TYPE m_CodecType;
+};
+
+#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 56ec6a3..5592bfe 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -11,6 +11,10 @@ endif
 ifeq (@USE_VAAPI@,1)
 SRCS += VAAPI.cpp
 endif
+ifeq (@USE_CRYSTALHD@,1)
+SRCS += CrystalHD.cpp
+SRCS += DVDVideoCodecCrystalHD.cpp
+endif
 ifeq ($(findstring osx,@ARCH@),osx)
 SRCS += DVDVideoCodecVDA.cpp
 SRCS += VDA.cpp
diff --git a/xbmc/settings/SettingConditions.cpp b/xbmc/settings/SettingConditions.cpp
index c313bd0..95089ce 100644
--- a/xbmc/settings/SettingConditions.cpp
+++ b/xbmc/settings/SettingConditions.cpp
@@ -29,6 +29,9 @@
 #include "android/activity/AndroidFeatures.h"
 #endif // defined(TARGET_ANDROID)
 #include "cores/AudioEngine/AEFactory.h"
+#if defined(HAVE_LIBCRYSTALHD)
+#include "cores/dvdplayer/DVDCodecs/Video/CrystalHD.h"
+#endif // defined(HAVE_LIBCRYSTALHD)
 #include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
 #include "guilib/LocalizeStrings.h"
 #include "peripherals/Peripherals.h"
@@ -224,6 +227,11 @@ void CSettingConditions::Initialize()
 #ifdef HAS_ZEROCONF
   m_simpleConditions.insert("has_zeroconf");
 #endif
+#ifdef HAVE_LIBCRYSTALHD
+  m_simpleConditions.insert("have_libcrystalhd");
+  if (CCrystalHD::GetInstance()->DevicePresent())
+    m_simpleConditions.insert("hascrystalhddevice");
+#endif
 #ifdef HAVE_LIBOPENMAX
   m_simpleConditions.insert("have_libopenmax");
 #endif
diff --git a/xbmc/system.h b/xbmc/system.h
index 2213421..cfe988b 100644
--- a/xbmc/system.h
+++ b/xbmc/system.h
@@ -106,6 +106,7 @@
 #define HAS_WIN32_NETWORK
 #define HAS_IRSERVERSUITE
 #define HAS_AUDIO
+#define HAVE_LIBCRYSTALHD 2
 #define HAS_WEB_SERVER
 #define HAS_WEB_INTERFACE
 #define HAVE_LIBSSH
diff --git a/xbmc/win32/WIN32Util.cpp b/xbmc/win32/WIN32Util.cpp
index 0bf3a98..eb41437 100644
--- a/xbmc/win32/WIN32Util.cpp
+++ b/xbmc/win32/WIN32Util.cpp
@@ -42,6 +42,12 @@
 
 #include <cassert>
 
+// default Broadcom registy bits (setup when installing a CrystalHD card)
+#define BC_REG_PATH       "Software\\Broadcom\\MediaPC"
+#define BC_REG_PRODUCT    "CrystalHD" // 70012/70015
+#define BC_BCM_DLL        "bcmDIL.dll"
+#define BC_REG_INST_PATH  "InstallPath"
+
 #define DLL_ENV_PATH "special://xbmc/system/;" \
                      "special://xbmc/system/players/dvdplayer/;" \
                      "special://xbmc/system/players/paplayer/;" \
@@ -1410,6 +1416,41 @@ bool CWIN32Util::UtilRegOpenKeyEx( const HKEY hKeyParent, const char *const pcKe
   return bRet;
 }
 
+bool CWIN32Util::GetCrystalHDLibraryPath(std::string &strPath)
+{
+  // support finding library by windows registry
+  HKEY hKey;
+  std::string strRegKey;
+
+  CLog::Log(LOGDEBUG, "CrystalHD: detecting CrystalHD installation path");
+  strRegKey = StringUtils::Format("%s\\%s", BC_REG_PATH, BC_REG_PRODUCT );
+
+  if( CWIN32Util::UtilRegOpenKeyEx( HKEY_LOCAL_MACHINE, strRegKey.c_str(), KEY_READ, &hKey ))
+  {
+    DWORD dwType;
+    char *pcPath= NULL;
+    if( CWIN32Util::UtilRegGetValue( hKey, BC_REG_INST_PATH, &dwType, &pcPath, NULL, sizeof( pcPath ) ) == ERROR_SUCCESS )
+    {
+      strPath = URIUtils::AddFileToFolder(pcPath, BC_BCM_DLL);
+      CLog::Log(LOGDEBUG, "CrystalHD: got CrystalHD installation path (%s)", strPath.c_str());
+      return true;
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "CrystalHD: getting CrystalHD installation path failed");
+    }
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "CrystalHD: CrystalHD software seems to be not installed.");
+  }
+  // check for dll in system dir
+  if(XFILE::CFile::Exists(DLL_PATH_LIBCRYSTALHD))
+    return true;
+  else
+    return false;
+}
+
 // Retrieve the filename of the process that currently has the focus.
 // Typically this will be some process using the system tray grabbing
 // the focus and causing XBMC to minimise. Logging the offending
diff --git a/xbmc/win32/WIN32Util.h b/xbmc/win32/WIN32Util.h
index 55b1ee8..83b6cb0 100644
--- a/xbmc/win32/WIN32Util.h
+++ b/xbmc/win32/WIN32Util.h
@@ -88,6 +88,8 @@ public:
   static LONG UtilRegGetValue( const HKEY hKey, const char *const pcKey, DWORD *const pdwType, char **const ppcBuffer, DWORD *const pdwSizeBuff, const DWORD dwSizeAdd );
   static bool UtilRegOpenKeyEx( const HKEY hKeyParent, const char *const pcKey, const REGSAM rsAccessRights, HKEY *hKey, const bool bReadX64= false );
 
+  static bool GetCrystalHDLibraryPath(std::string &strPath);
+
   static bool GetFocussedProcess(std::string &strProcessFile);
   static void CropSource(CRect& src, CRect& dst, CRect target);
 
-- 
2.1.0

